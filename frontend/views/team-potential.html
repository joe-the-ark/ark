{% load i18n %}
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link rel="icon" href="/static/images/favicon.ico"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1"/>
    <meta name="theme-color" content="#51ceec"/>
    <meta name="description" content="ARK"/>
    <title>Psychological-Safe-Circles</title>
    <link rel="stylesheet" href="/static/css/app.css">
    <link rel="stylesheet" href="/static/css/app_graph.css">
    <link rel="stylesheet" href="/static/css/team-potential.css">
    <link rel="stylesheet" href="/static/css/team-potential-google-slides.css">

    <script src="/static/vue.js"></script>
    <!-- ÂºïÂÖ•Ê†∑Âºè -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/element-ui/2.15.9/theme-chalk/index.css">
    <!-- ÂºïÂÖ•ÁªÑ‰ª∂Â∫ì -->
    <script src="https://cdn.staticfile.org/element-ui/2.15.9/index.js"></script>
    <script>
        // Initialize Element UI with Vue
        if (typeof Vue !== 'undefined' && typeof ELEMENT !== 'undefined') {
            Vue.use(ELEMENT);
        }
    </script>
    <!-- Tippy.js for tooltips -->
    <script src="https://unpkg.com/@popperjs/core@2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6/dist/tippy-bundle.umd.js"></script>
</head>
<body>
<div class="app">
    <div class="app__head">
        <header class="header-main container">
            <div class="header-main__title">
                <icon class="icon" onClick="window.open('https://info.arks.ch/');">
                <span class="icon-logo"></span>
                <span>ARKS</span>
                <span id="arks-logo-tooltip-icon" class="tooltip-icon" style="display: none;">{% trans "Info zu safecircles.ch" %}</span>
            </icon>
            </div>
            <div class="header-main__user">
                <div class="user">
                    <div class="user__subtitle">
                        {{game.name}}
                    </div>
                    <img src="{{ user.avatar }}" alt="boar">
                    <div class="user__title">
                        {{ user.name }}
                    </div>
                </div>
            </div>
            <div class="header-main__progress">
                <div class="progress">
                    <div class="progress__bar">
                        <div class="progress__bar-fill">85%</div>
                    </div>
                </div>
                <button class="button" onclick="prepareCanvasForPrint(); window.print();" aria-label="{% trans 'Als PDF speichern' %}" title="{% trans 'Als PDF speichern' %}">{% trans "Als PDF speichern" %}</button> 
            </div>



        </header>
    </div>
    <div class="app__body" id="app-1">
        <div class="container"
        v-loading="loading"
        element-loading-text="Waiting for others to finish"
        element-loading-background="rgba(0, 0, 0, 0.8)">
            <main class="screen auth">
                <h1 class="team-potential-heading-tooltip">
                    <span 
                        id="team-potential-title-tooltip-icon"
                        class="tooltip-icon"
                        tabindex="0"
                        aria-label="{% trans 'Tooltip anzeigen' %}"
                    >
                        ?
                    </span>
                    {% trans "Sichere Kreise im Team boosten" %}
                </h1>

                <div style="border: 1px solid #ccc; border-radius: 10px; padding: 10px;">

                <p style="background-color: #9FE2BF; color: #626262; border-radius: 10px; padding: 0 10px;">
                            <br>
                            <span 
                                id="prio1-heading-tooltip-icon"
                                class="prio1-tooltip-container"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-right: 8px; vertical-align: middle;"
                            >
                                <span 
                                    id="prio1-tooltip-icon"
                                    class="tooltip-icon prio1-tooltip-icon"
                                    title="{% trans 'Klicken f√ºr Anweisungen' %}"
                                >
                                    ?
                                </span>
                            </span>
                            {% trans "PRIO 1: Integratoren st√§rken ‚Äì " %}{% trans "diese Konstellation erm√∂glicht euch ein " %}<button @click="setToleranceValue(getValue4())" style="background-color: #FFFFFF; border: 5px solid #75CBE8; color: black;">{% trans "maximales Mass an psychologischer Sicherheit beim Toleranzfenster" %} [[ getValue4() ]]</button><br>                            {% trans "Wer ist in mehreren sicheren Kreisen und wirkt integrierend?" %}<br>
                            <span 
                                id="prio1-integrator-tooltip-icon"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-left: 0; vertical-align: middle;"
                            >
                                {% trans "Wie weiter" %}
                                <span 
                                    class="tooltip-icon"
                                    title="{% trans 'PRIO 1-Erkl√§rung' %}"
                                >
                                    ?
                                </span>
                            </span>
                            <br><br>
                </p>
<!--

                <div class="safe-circles-overview" style="margin: 20px 0; padding: 20px; background-color: #f5f5f5; border-radius: 10px; border: 2px solid #9FE2BF;">
                    <h3 style="margin: 0 0 15px 0; color: #626262; font-size: 18px; font-weight: bold;">
                        {% trans "Sichere Kreise beim Toleranzfenster" %} [[ current ]]
                    </h3>


                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px;">
                        <div 
                            v-for="(circle, idx) in getCirclesDetailed()" 
                            :key="idx"
                            class="circle-card"
                            :style="{ borderLeft: '5px solid ' + circle.color }"
                            style="background-color: #FFFFFF; padding: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);"
                        >
                            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                <div 
                                    :style="{ backgroundColor: circle.color, width: '20px', height: '20px', borderRadius: '50%', marginRight: '10px' }"
                                ></div>
                                <strong style="color: #626262; font-size: 16px;">
                                    {% trans "Kreis" %} [[ idx + 1 ]]
                                </strong>
                                <span style="margin-left: auto; color: #9FE2BF; font-weight: bold; font-size: 14px;">
                                    [[ circle.memberCount ]] {% trans "Personen" %}
                                </span>
                            </div>
                            <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                <span 
                                    v-for="(member, memberIdx) in circle.members"
                                    :key="memberIdx"
                                    :style="member.isIntegrator ? 'background-color: #f0f0f0; padding: 6px 12px; border-radius: 20px; font-size: 14px; color: #626262; display: inline-flex; align-items: center; border: 2px solid #9FE2BF; box-shadow: 0 0 0 2px rgba(159, 226, 191, 0.3);' : 'background-color: #f0f0f0; padding: 6px 12px; border-radius: 20px; font-size: 14px; color: #626262; display: inline-flex; align-items: center;'"
                                >
                                    <img 
                                        v-if="member.avatar"
                                        :src="member.avatar"
                                        :alt="member.name"
                                        :style="member.isIntegrator ? 'width: 24px; height: 24px; border-radius: 50%; margin-right: 8px; object-fit: cover; border: 2px solid #9FE2BF;' : 'width: 24px; height: 24px; border-radius: 50%; margin-right: 8px; object-fit: cover; border: 2px solid #FFFFFF;'"
                                    />
                                    <span v-else style="margin-right: 6px;">üë§</span>
                                    [[ member.name ]]
                                    <span v-if="member.count > 0" style="margin-left: 6px; color: #9FE2BF; font-weight: bold;">
                                        ([[ member.count ]])
                                    </span>
                                </span>
                            </div>
                        </div>
                    </div>


-->

                    <div v-if="getCirclesDetailed().length === 0" style="text-align: center; padding: 20px; color: #999;">
                        {% trans "Keine sicheren Kreise bei diesem Toleranzfenster-Wert" %}
                    </div>
                </div>

                <div class="center">
                  <p style="float:none; display: inline">
                    <br>[[ getCircles().length ]] {% trans "SICHERE KREISE bei der Toleranzfenster-Gr√∂sse" %} <span style="font-weight: bold; font-size: 42px; color: #626262; vertical-align: middle;">[[ current ]]</span>
                    
                    <!-- Total Safe Connections Display -->
                    <div style="display: inline-flex; align-items: center; gap: 10px; margin-left: 20px; padding: 12px 20px; background-color: #9FE2BF; border-radius: 8px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);">
                        <span style="font-size: 16px; font-weight: bold; color: #FFFFFF;">{% trans "Summe aller sicherer Kreise:" %}</span>
                        <span style="font-size: 24px; font-weight: bold; color: #FFFFFF;">[[ getTotalSafeConnections() ]]</span>
                    </div>
                    
                    <!-- Improved Tolerance Window Input Container -->
                    <div class="tolerance-window-input-container" style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin: 20px 0; padding: 20px; background-color: #f5f5f5; border-radius: 10px; border: 2px solid #9FE2BF;">
                        <div style="display: flex; align-items: center; gap: 10px; width: 100%; max-width: 900px;">
                            <label for="tolerance-window-input" style="font-weight: bold; color: #626262; white-space: nowrap;">
                                {% trans "Toleranzfenster:" %}
                            </label>
                            <div style="position: relative; flex: 1; display: flex; align-items: center; gap: 10px;">
                                <!-- Range Slider with gradient background -->
                                <div style="position: relative; flex: 1.5; min-width: 450px; height: 50px; border-radius: 5px;" :style="getSliderGradientBackgroundStyle()">
                                    <input 
                                        type="range" 
                                        id="tolerance-window-slider"
                                        v-model.number="current" 
                                        @input="handleSliderInput"
                                        @change="handleSliderChange"
                                        :min="getMinTolerance()" 
                                        :max="getValue2()" 
                                        step="1"
                                        style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; margin: 0; padding: 0; background: transparent; outline: none; cursor: pointer; z-index: 1;"
                                        class="tolerance-slider"
                                        aria-label="{% trans 'Toleranzfenster einstellen' %}"
                                        aria-valuemin="getMinTolerance()"
                                        aria-valuemax="getValue2()"
                                        :aria-valuenow="current"
                                    />
                                </div>
                                <!-- Number Input -->
                                <input 
                                    type="number" 
                                    id="tolerance-window-input"
                                    v-model.number="current" 
                                    :min="getMinTolerance()" 
                                    :max="getValue2()" 
                                    style="width: 100px; height: 50px; padding: 10px; border-radius: 10px; border: 3px solid #9FE2BF; font-size: 20px; font-weight: bold; text-align: center; background-color: #E29635; color: #626262; box-shadow: 0 2px 5px rgba(0,0,0,0.1);" 
                                    aria-label="{% trans 'Toleranzfenster-Wert eingeben' %}"
                                    aria-valuemin="getMinTolerance()"
                                    aria-valuemax="getValue2()"
                                    :aria-valuenow="current"
                                />
                                <!-- Tooltip Icon -->
                                <span 
                                    id="tolerance-window-tooltip-icon"
                                    class="tooltip-icon"
                                    title="{% trans 'Toleranzfenster-Erkl√§rung' %}"
                                >
                                    ?
                                </span>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 5px; font-size: 14px; color: #626262;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <button 
                                    @click="hideReadingHelp()"
                                    id="min-value-button"
                                    :style="hasInGroupsAtMin() ? 'font-weight: bold; font-size: 42px; color: #FFD700; background: none; border: none; cursor: pointer; padding: 0; margin: 0; text-decoration: underline;' : 'font-weight: bold; font-size: 42px; color: #626262; background: none; border: none; cursor: pointer; padding: 0; margin: 0; text-decoration: underline;'"
                                    :aria-label="hasInGroupsAtMin() ? '{% trans 'Niedrigster Wert mit In-Groups (goldene Linien)'|escapejs %}: ' + getMinTolerance() : '{% trans 'Niedrigster Wert mit erstem Safecircle'|escapejs %}: ' + getMinTolerance()"
                                    :title="hasInGroupsAtMin() ? '{% trans 'Niedrigster Wert - zeigt In-Groups (goldene Linien)' %}' : '{% trans 'Niedrigster Wert - zeigt ersten Safecircle' %}'"
                                    tabindex="0"
                                >
                                    [[ getMinTolerance() ]]
                                </button>
                                <span v-if="hasInGroupsAtMin()" style="font-size: 24px; color: #FFD700;" title="{% trans 'In-Groups (goldene Linien) vorhanden' %}" aria-label="{% trans 'In-Groups vorhanden' %}">‚óè</span>
                            </div>
                            <span style="flex: 1; text-align: center; font-style: italic;">{% trans "(niedrige Werte = hoher Stress)" %}</span>
                            <button 
                                @click="hideMaxValueHelp()"
                                id="max-value-button"
                                style="font-weight: bold; font-size: 42px; color: #626262; background: none; border: none; cursor: pointer; padding: 0; margin: 0; text-decoration: underline;"
                                :aria-label="'{% trans 'Maximalwert-Erkl√§rung' %}: ' + getValue2()"
                                title="{% trans 'Maximalwert-Erkl√§rung' %}"
                                tabindex="0"
                            >
                                [[ getValue2() ]]
                            </button>
                        </div>
                    </div>
                    
                    <br/>
                    <div style="position: relative; display: inline-block; background-color: #f0f0f0;">
                        <canvas 
                            ref="canvas" 
                            :width="width" 
                            :height="height" 
                            :style="{ width:width+'px', height:height+'px', display: (viewMode === 'canvas' || viewMode === 'expanded') ? 'block' : 'none', transition: 'opacity 0.3s ease', backgroundColor: '#FFFFFF' }" 
                            id="team-potential-canvas"
                            role="img"
                            :aria-label="'{% trans 'Team-Potential-Visualisierung' %}: {% trans 'Toleranzfenster' %} ' + current + (viewMode === 'expanded' ? ' ({% trans 'erweiterte Ansicht' %})' : '')"
                            tabindex="0"
                        ></canvas>
                        <!-- Expanded view indicator (simplified) -->
                        <div v-if="viewMode === 'expanded'" style="position: absolute; top: 10px; right: 10px; background-color: rgba(255, 255, 255, 0.95); padding: 8px 12px; border-radius: 8px; font-size: 12px; color: #626262; box-shadow: 0 2px 6px rgba(0,0,0,0.25); z-index: 10;">
                            {% trans "Leertaste" %} - {% trans "f√ºr normale Ansicht" %}
                        </div>
                        <!-- Clickable arrow navigation with tolerance value display (expanded view) -->
                        <div v-if="viewMode === 'expanded'" style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); display: flex; align-items: center; gap: 15px; z-index: 10;">
                            <!-- Left arrow button -->
                            <button 
                                @click="decreaseTolerance"
                                :disabled="current <= getMinTolerance()"
                                :style="{
                                    backgroundColor: current <= getMinTolerance() ? 'rgba(200, 200, 200, 0.5)' : 'rgba(255, 255, 255, 0.95)',
                                    border: 'none',
                                    borderRadius: '50%',
                                    width: '60px',
                                    height: '60px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    boxShadow: current <= getMinTolerance() ? '0 1px 3px rgba(0,0,0,0.1)' : '0 2px 8px rgba(0,0,0,0.25)',
                                    cursor: current <= getMinTolerance() ? 'not-allowed' : 'pointer',
                                    transition: 'all 0.2s ease',
                                    opacity: current <= getMinTolerance() ? 0.5 : 1
                                }"
                                @mouseenter="e => { if (current > getMinTolerance()) e.target.style.transform = 'scale(1.1)'; }"
                                @mouseleave="e => { e.target.style.transform = 'scale(1)'; }"
                                aria-label="{% trans 'Toleranzfenster verringern' %}"
                            >
                                <span style="font-size: 28px; color: #626262;">‚Üê</span>
                            </button>
                            
                            <!-- Tolerance value display -->
                            <div style="background-color: rgba(255, 255, 255, 0.95); padding: 12px 20px; border-radius: 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); min-width: 100px; text-align: center;">
                                <div style="font-size: 11px; color: #999; margin-bottom: 4px; text-transform: uppercase;">{% trans "Toleranzfenster" %}</div>
                                <div style="font-weight: bold; font-size: 32px; color: #E29635; line-height: 1;">[[ current ]]</div>
                                <div style="font-size: 10px; color: #999; margin-top: 4px;">
                                    [[ getMinTolerance() ]] - [[ getValue2() ]]
                                </div>
                            </div>
                            
                            <!-- Right arrow button -->
                            <button 
                                @click="increaseTolerance"
                                :disabled="current >= getValue2()"
                                :style="{
                                    backgroundColor: current >= getValue2() ? 'rgba(200, 200, 200, 0.5)' : 'rgba(255, 255, 255, 0.95)',
                                    border: 'none',
                                    borderRadius: '50%',
                                    width: '60px',
                                    height: '60px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center',
                                    boxShadow: current >= getValue2() ? '0 1px 3px rgba(0,0,0,0.1)' : '0 2px 8px rgba(0,0,0,0.25)',
                                    cursor: current >= getValue2() ? 'not-allowed' : 'pointer',
                                    transition: 'all 0.2s ease',
                                    opacity: current >= getValue2() ? 0.5 : 1
                                }"
                                @mouseenter="e => { if (current < getValue2()) e.target.style.transform = 'scale(1.1)'; }"
                                @mouseleave="e => { e.target.style.transform = 'scale(1)'; }"
                                aria-label="{% trans 'Toleranzfenster erh√∂hen' %}"
                            >
                                <span style="font-size: 28px; color: #626262;">‚Üí</span>
                            </button>
                        </div>
                        <!-- Hint for normal view: how to switch to expanded view -->
                        <div v-if="viewMode === 'canvas'" style="position: absolute; bottom: 10px; right: 10px; background-color: rgba(255, 255, 255, 0.85); padding: 6px 10px; border-radius: 5px; font-size: 11px; color: #626262; box-shadow: 0 2px 4px rgba(0,0,0,0.15); z-index: 10; pointer-events: none; opacity: 0.8;">
                            üí° {% trans "Leertaste f√ºr erweiterte Ansicht" %}
                        </div>
                        <!-- Keyboard navigation hint (always visible when canvas is shown) -->
                        <div v-if="viewMode === 'canvas' || viewMode === 'expanded'" style="position: absolute; bottom: 10px; left: 10px; background-color: rgba(255, 255, 255, 0.85); padding: 6px 10px; border-radius: 5px; font-size: 11px; color: #626262; box-shadow: 0 2px 4px rgba(0,0,0,0.15); z-index: 10; pointer-events: none; opacity: 0.7; display: flex; align-items: center; gap: 4px;">
                            <span style="font-size: 14px;">‚Üê ‚Üí</span>
                            <span>{% trans "Pfeiltasten f√ºr Toleranzfenster" %}</span>
                        </div>
                    </div>
                    <div v-if="viewMode === 'overview'" style="min-height: 400px; padding: 20px; background-color: #f5f5f5; border-radius: 10px; text-align: center;">
                        <h3 style="color: #626262; margin-bottom: 20px;">{% trans "√úbersichtsansicht" %}</h3>
                        <p style="color: #999;">{% trans "Dr√ºcke Leertaste, um zur Canvas-Ansicht zur√ºckzukehren" %}</p>
                    </div>
                  </p>
                </div>
                
                <!-- Player Detail Modal -->
                <div 
                    v-if="showPlayerDetail && selectedPlayer !== null" 
                    class="player-detail-modal"
                    @click.self="closePlayerDetail()"
                >
                    <div class="player-detail-content" v-if="getPlayerDetails(selectedPlayer)">
                        <div class="player-detail-header">
                            <button class="player-detail-close" @click="closePlayerDetail()" aria-label="{% trans 'Spieler-Detail schlie√üen' %}" title="{% trans 'Schlie√üen' %}">√ó</button>
                            <h2>[[ getPlayerDetails(selectedPlayer).name ]]</h2>
                        </div>
                        <div class="player-detail-body">
                            <div class="player-detail-avatar-section">
                                <img 
                                    :src="getPlayerDetails(selectedPlayer).avatar" 
                                    :alt="getPlayerDetails(selectedPlayer).name"
                                    class="player-detail-avatar"
                                />
                                <div class="player-detail-role" :class="{ 'integrator': getPlayerDetails(selectedPlayer).isIntegrator }">
                                    [[ getPlayerDetails(selectedPlayer).role ]]
                                </div>
                                <div v-if="getPlayerDetails(selectedPlayer).safetyAnchor" class="player-detail-anchor">
                                    <strong>{% trans "Sicherheitsanker:" %}</strong> [[ getPlayerDetails(selectedPlayer).safetyAnchor ]]
                                </div>
                            </div>
                            
                            <div class="player-detail-stats">
                                <div class="player-detail-stat">
                                    <span class="stat-label">{% trans "Safecircle-Anzahl:" %}</span>
                                    <span class="stat-value">[[ getPlayerDetails(selectedPlayer).circleCount ]]</span>
                                </div>
                                <div class="player-detail-stat" v-if="getPlayerDetails(selectedPlayer).inGroups.length > 0">
                                    <span class="stat-label">{% trans "In-Groups:" %}</span>
                                    <span class="stat-value">[[ getPlayerDetails(selectedPlayer).inGroups.length ]]</span>
                                </div>
                            </div>
                            
                            <div v-if="getPlayerDetails(selectedPlayer).circles.length > 0" class="player-detail-section">
                                <h3 class="player-detail-section-title-circles">{% trans "Sichere Kreise:" %}</h3>
                                <div 
                                    v-for="(circle, idx) in getPlayerDetails(selectedPlayer).circles" 
                                    :key="idx"
                                    class="player-detail-circle"
                                    :style="{ borderLeftColor: circle.color }"
                                >
                                    <div class="player-detail-circle-header">
                                        <span class="player-detail-circle-color-indicator" :style="{ backgroundColor: circle.color }"></span>
                                        <strong>{% trans "Kreis" %} [[ circle.index + 1 ]]:</strong>
                                        <span class="player-detail-circle-tolerance">
                                            {% trans "Toleranzfenster:" %} [[ current ]]
                                        </span>
                                    </div>
                                    <div class="player-detail-circle-members">
                                        <span 
                                            v-for="(member, memberIdx) in circle.members" 
                                            :key="memberIdx"
                                            class="player-detail-circle-member"
                                            :class="{ 'integrator': member.isIntegrator, 'current-player': member.isCurrentPlayer }"
                                        >
                                            <img 
                                                v-if="member.avatar"
                                                :src="member.avatar" 
                                                :alt="member.name"
                                                class="player-detail-circle-member-avatar"
                                            />
                                            <span v-else class="player-detail-circle-member-avatar-placeholder">üë§</span>
                                            <div class="player-detail-circle-member-info">
                                                <span class="player-detail-circle-member-name">[[ member.name ]]</span>
                                                <span v-if="member.safetyAnchor" class="player-detail-circle-member-anchor">[[ member.safetyAnchor ]]</span>
                                            </div>
                                            <span v-if="member.isIntegrator" class="player-detail-circle-member-badge">{% trans "Integrator" %}</span>
                                        </span>
                                    </div>
                                </div>
                            </div>
                            
                            <div v-if="getPlayerDetails(selectedPlayer).inGroups.length > 0" class="player-detail-section">
                                <h3>{% trans "In-Groups:" %}</h3>
                                <div 
                                    v-for="(group, idx) in getPlayerDetails(selectedPlayer).inGroups" 
                                    :key="idx"
                                    class="player-detail-in-group"
                                >
                                    <div class="player-detail-in-group-header">
                                        <span class="player-detail-in-group-tolerance">
                                            {% trans "Toleranzfenster:" %} [[ current ]]
                                        </span>
                                    </div>
                                    <div class="player-detail-circle-members">
                                        <span 
                                            v-for="(member, memberIdx) in group.members" 
                                            :key="memberIdx"
                                            class="player-detail-circle-member"
                                            :class="{ 'integrator': member.isIntegrator, 'current-player': member.isCurrentPlayer }"
                                        >
                                            <img 
                                                v-if="member.avatar"
                                                :src="member.avatar" 
                                                :alt="member.name"
                                                class="player-detail-circle-member-avatar"
                                            />
                                            <span v-else class="player-detail-circle-member-avatar-placeholder">üë§</span>
                                            <div class="player-detail-circle-member-info">
                                                <span class="player-detail-circle-member-name">[[ member.name ]]</span>
                                                <span v-if="member.safetyAnchor" class="player-detail-circle-member-anchor">[[ member.safetyAnchor ]]</span>
                                            </div>
                                            <span v-if="member.isIntegrator" class="player-detail-circle-member-badge">{% trans "Integrator" %}</span>
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <p style="background-color: #9FE2BF; color: #626262; text-align: left; border-radius: 10px; padding: 0 10px;"><br>
                            <span 
                                id="prio2-heading-tooltip-icon"
                                class="prio2-tooltip-container"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-right: 8px; vertical-align: middle;"
                            >
                                <span 
                                    id="prio2-tooltip-icon"
                                    class="tooltip-icon prio2-tooltip-icon"
                                    title="{% trans 'Klicken f√ºr Anweisungen' %}"
                                >
                                    ?
                                </span>
                            </span>
                       {% trans "PRIO 2: Satelliten integrieren ‚Äì " %}{% trans "beim Toleranzfenster-Wert von " %}<button @click="setToleranceValue(getValue3())" style="background-color: #FFFFFF; border: 5px solid #52CEEC; color: black;">[[ getValue3() ]] </button>{% trans " (hier klicken) siehst du, wer zuerst SOLO ist. " %}<button @click="setToleranceValue(getValue3()+1)" style="background-color: #FFFFFF; border: 5px solid #52CEEC; color: black;">{% trans "Booste Satelliten" %}</button> {% trans " und erkenne, wer Hand in einen sicheren Kreis bieten kann." %}<br>
                       <span 
                           id="prio2-integrator-tooltip-icon"
                           style="display: inline-flex; align-items: center; gap: 4px; margin-left: 0; vertical-align: middle;"
                       >
                           {% trans "Wie weiter" %}
                           <span 
                               class="tooltip-icon"
                               title="{% trans 'PRIO 2-Erkl√§rung' %}"
                           >
                               ?
                           </span>
                       </span>
                       <br><br>
                </p>

                <p style="background-color: #52CEEC; text-align: left; color: #FFFFFF; border-radius: 10px; padding: 0 10px;"><br>
                            <span 
                                id="prio3-heading-tooltip-icon"
                                class="prio3-tooltip-container"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-right: 8px; vertical-align: middle;"
                            >
                                <span 
                                    id="prio3-tooltip-icon"
                                    class="tooltip-icon tooltip-icon-green prio3-tooltip-icon"
                                    title="{% trans 'Klicken f√ºr Anweisungen' %}"
                                >
                                    ?
                                </span>
                            </span>
                            {% trans "PRIO 3: Boss-Zentralit√§t erh√∂hen ‚Äì " %}{% trans "die Konstellation beim " %}<button  @click="setToleranceValue(16)" style="border: 5px solid #9FE2BF;">{% trans "Standard-Toleranzfenster von 16" %}</button>{% trans " k√∂nnte der IST-Situation im Team nahekommen. Wie sicher verbunden ist der Boss?" %}<br>
                            <span 
                                id="prio3-integrator-tooltip-icon"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-left: 0; vertical-align: middle;"
                            >
                                {% trans "Wie weiter" %}
                                <span 
                                    class="tooltip-icon tooltip-icon-green"
                                    title="{% trans 'PRIO 3-Erkl√§rung' %}"
                                >
                                    ?
                                </span>
                            </span>
                            <br><br>
                </p>

                <p v-if="hasGoldenLines" style="background-color: #FFD700; text-align: left; color: #626262; border-radius: 10px; padding: 0 10px;"><br>
                            <span 
                                id="prio4-heading-tooltip-icon"
                                class="prio4-tooltip-container"
                                style="display: inline-flex; align-items: center; gap: 4px; margin-right: 8px; vertical-align: middle;"
                            >
                                <span 
                                    id="prio4-tooltip-icon"
                                    class="tooltip-icon prio4-tooltip-icon"
                                    title="{% trans 'Klicken f√ºr Anweisungen' %}"
                                >
                                    ?
                                </span>
                            </span>
                            {% trans "PRIO 4: In-Gruppen und Seilschaften in die Verantwortung nehmen (Goldene Linien)" %}<br><br>
                </p>

                <p style="background-color: #fffff; text-align: left; color: #00000; border-radius: 10px; padding: 0 10px;"><br>
                            {% trans "" %}<br><br>
                </p>

                <p id="reading-help-section" style="display: none; background-color: #9FE2BF; color: #626262; border-radius: 10px; padding: 0 10px;">
                            <br>
                            {% trans "Eine Lesehilfe: je kleiner der Zahlenwert, desto mehr Stress und negative Trigger zeigen sich, weil sich die Toleranzfenster der Teammitglieder schliessen." %}<br>
                            <button @click="setToleranceValue(getValue1())" style="border: 5px solid #9FE2BF;">{% trans "Im ersten sicheren Kreise bei" %} [[ getValue1() ]]</button>{% trans " (hier klicken) funktioniert die Zusammenarbeit auch bei sehr grossem Stress noch ohne Drama." %}<br>
                            <br>
                </p>

                <p id="max-value-help-section" style="display: none; background-color: #fffff; text-align: left; color: #00000; border-radius: 10px; padding: 0 10px;"><br>
                            {% trans "Aktuell seid ihr beim Toleranzfenster von " %}<button @click="setToleranceValue(getValue2())" style="border: 5px solid #9FE2BF;">[[ getValue2() ]] {% trans " alle in EINEM sicheren Kreis." %}</button><br>{% trans "Wenn Einzelne auf undifferenzierte Einigkeit dr√§ngen, zeigt sich das an einer Toleranzfenster-Gr√∂sse von √ºber 35, bei dem die Teamdynamik schon sektenartige Z√ºge tragen kann. Ein weiterer Indikator f√ºr ein ungesundes Mass an erwarteter Konformit√§t zeigt sich bei Werten unter 25, die auf eine Gefahr von Groupthink deutet." %}<br><br>
                </p><br>

            </div>

            </main>

                <div class="center">

                        <span>
                            <a href="/arche/">
                            <button class="button button-primary" type="button">
                                <span class="button-text">{% trans "Aftercare" %}</span>
                                <span class="button-arrow">‚Üí</span>
                            </button></a>
                        </span>


                        <p style="text-align: center; font-size: 10px;">
                            <div class="copyright-footer">
                                <a href="https://github.com/joe-the-ark/ark" target="_blank">{% trans "ARKS is published under a GPLv3" %}</a> {% trans "license by" %} 
                                <a href="https://www.linkedin.com/in/dr-joe-maier/" target="_blank">{% trans "Dr. Joe Maier" %}</a>.
                            </div>
                        </p>
                </div>

                <div class="google-slides-container-wrapper" style="position: relative; margin-top: 40px;">
                    <button class="google-slides-fullscreen-button" id="google-slides-fullscreen-button" aria-label="{% trans 'Vollbild anzeigen' %}" title="{% trans 'Vollbild anzeigen' %}">
                        <span class="fullscreen-icon">‚õ∂</span>
                    </button>
                    <div class="google-slides-container" id="google-slides-container">
                        <iframe src={% trans "https://docs.google.com/presentation/d/1qi3wNhpRU3FEoatghY7Ca0iNwtGPQGvHqLRXCvbKKJ8/embed?start=true&loop=false&delayms=8000&rm=minimal"  %} frameborder="0" allowfullscreen="true" mozallowfullscreen="true" webkitallowfullscreen="true"></iframe>
                    </div>
                </div>

                {% comment %}<p class="spanun-p" style="background-color: #FFFFFF; color: #626262; border-radius: 10px; padding: 0 10px;">
                            {% trans "Zum Abschluss empfehlen wir eine anonyme Feedbackrunde mit 3 bew√§hrten Fragen zur St√§rkung der psychologischen Sicherheit im Team: Dieser Feedbackprozess ist Voraussetzung, damit die hier noch anonym dargestellten Einsch√§tzungen der anderen Teammitglieder offengelegt werden k√∂nnen." %}
                <br><br><br></p>{% endcomment %}

        </div>

    </div>
</div>
{{ prio1_tooltip_text|json_script:"prio1-tooltip-text" }}
{{ prio2_tooltip_text|json_script:"prio2-tooltip-text" }}
{{ prio3_tooltip_text|json_script:"prio3-tooltip-text" }}
{{ prio4_tooltip_text|json_script:"prio4-tooltip-text" }}
{{ circles|json_script:"circles-data" }}
{{ players|json_script:"players-data" }}
{{ anchors|json_script:"anchors-data" }}
{{ all_result|json_script:"all-result-data" }}
{{ in_groups|json_script:"in-groups-data" }}
<script src="/static/js/AppGraph.js"></script>
<script src="/static/axios.min.js"></script>
<script>
/**
 * Team Potential Visualization
 * 
 * This Vue.js application visualizes safecircles and in-groups for team dynamics.
 * Features:
 * - Interactive tolerance window slider
 * - Canvas visualization with safecircles and in-groups
 * - Player detail modal
 * - Keyboard navigation (Arrow keys, Space)
 * - Smooth animations
 */

/**
 * Parse JSON data from json_script tags - ensures proper Unicode handling for Firefox
 * @param {string} id - The ID of the script element containing JSON data
 * @param {*} defaultValue - Default value to return if parsing fails
 * @returns {*} Parsed JSON data or defaultValue
 */
function parseJsonScript(id, defaultValue) {
    const element = document.getElementById(id);
    if (!element) {
        console.error('JSON script element not found:', id);
        return defaultValue;
    }
    try {
        return JSON.parse(element.textContent);
    } catch(e) {
        console.error('Error parsing JSON from', id, ':', e);
        console.error('Element textContent:', element.textContent.substring(0, 200));
        return defaultValue;
    }
}

// Ensure DOM is ready before parsing
function initTeamPotential() {
    // Prevent multiple initializations
    if (window.teamPotentialInitialized) {
        console.warn('Team potential already initialized, skipping...');
        return;
    }
    
    // Also check if Vue instance already exists
    if (window.app1 && window.app1.$el) {
        console.warn('Vue app already exists, skipping initialization...');
        return;
    }
    
    window.teamPotentialInitialized = true;
    
    const circlesData = parseJsonScript('circles-data', {});
    const playersData = parseJsonScript('players-data', {});
    const anchorsData = parseJsonScript('anchors-data', {});
    const allResultData = parseJsonScript('all-result-data', []);
    const inGroupsData = parseJsonScript('in-groups-data', []);
    
    // Store allResultData globally for later use
    window.allResultData = allResultData;

const app1 = new Vue({
    delimiters: ['[[', ']]'],
    el: '#app-1',
    data() {
        return {
            loading: false,
            circles: circlesData,
            players: playersData,
            anchors: anchorsData,
            allResult: allResultData,       // raw statusSide data for each player
            inGroups: inGroupsData,         // in-groups data
            current: 16,
            width: 1000,
            height: 1000,
            // Animation state
            animationFrame: null,
            isAnimating: false,
            // Player detail view
            selectedPlayer: null,
            playerPositions: {}, // Store player positions for click detection
            playerPositionsArray: [], // Array version for Vue reactivity
            showPlayerDetail: false,
            // View toggle
            viewMode: 'canvas', // 'canvas', 'overview', or 'expanded'
            expandedPadding: 300, // Additional padding in pixels for expanded view
            // Hover state
            hoveredPlayerIndex: null, // Index of currently hovered player
            // Force-Directed Layout
            useForceLayout: true, // Toggle between circular and force-directed layout
            forceLayoutPositions: {}, // Store calculated positions
            forceLayoutInitialized: false
        };
    },
    created() {
        // Ensure isAnimating is false from the start
        this.isAnimating = false;
        this._animationStartTime = 0;
        this.current = this.getValue4();
        this.loading = '{{ loading }}' !== '0';
        
        // Calculate optimal canvas size based on team size and view mode
        this.calculateOptimalCanvasSize();
    },
    mounted() {
        // Ensure isAnimating is false on mount
        this.isAnimating = false;
        this._animationStartTime = 0;
        
        // Recalculate canvas size on mount (in case window size changed)
        this.calculateOptimalCanvasSize();
        
        // Use $nextTick to ensure DOM refs are available
        this.$nextTick(() => {
            // Wait for canvas to be fully initialized and size to be set
            if (this.$refs.canvas) {
                // Ensure canvas dimensions are set
                this.$refs.canvas.width = this.width;
                this.$refs.canvas.height = this.height;
                // Force a redraw after canvas is ready
                this.$nextTick(() => {
                    this.redraw();
                    // Additional redraw after a short delay to ensure all images are loaded and force layout is complete
                    setTimeout(() => {
                        this.redraw();
                    }, 200);
                });
            }
            this.setupKeyboardShortcuts();
            this.setupCanvasClickHandlers();
        });
        // Make app1 globally accessible for keyboard handlers
        window.app1 = this;
    },
    beforeDestroy() {
        // Clean up event listeners
        if (this._keyboardHandler) {
            document.removeEventListener('keydown', this._keyboardHandler, true);
            this._keyboardHandler = null;
        }
    },
    computed: {
        hasGoldenLines() {
            // Check if there are any golden lines (in-groups/seilschaften) in the team
            // The inGroups data contains all golden lines with their tolerance ranges
            const inGroups = this.inGroups;
            if (!inGroups || !Array.isArray(inGroups) || inGroups.length === 0) {
                return false;
            }
            
            // Simply check if there are any in-groups defined
            // Each in-group represents a golden line that exists for a range of tolerance values
            return true;
        },
        totalSafeConnectionsLabel() {
            // Label for total safe connections (sum of all safe circles available to all team members)
            return 'Summe aller sicherer Kreise:';
        }
    },
    methods: {
        /**
         * Calculate optimal canvas size based on team size and number of circles
         */
        calculateOptimalCanvasSize() {
            // Base canvas size: 1000x1000 pixels
            // In expanded mode, add padding to show content that might be cut off
            const baseSize = 1000;
            if (this.viewMode === 'expanded') {
                this.width = baseSize + (this.expandedPadding * 2);
                this.height = baseSize + (this.expandedPadding * 2);
            } else {
                this.width = baseSize;
                this.height = baseSize;
            }
        },
        /**
         * Force-Directed Layout Calculation
         * @param {number} n - Number of players
         * @param {Array} circles - Array of circles (arrays of player indices)
         * @param {Array} dyads - Array of dyads (pairs of player indices)
         * @param {number} centerX - Center X coordinate
         * @param {number} centerY - Center Y coordinate
         * @param {number} baseRadius - Base radius for initial positioning
         */
        calculateForceLayout(n, circles, dyads, centerX, centerY, baseRadius) {
            const layoutKey = `${n}_${this.current}`;
            // Initialize force layout positions storage
            if (!this.forceLayoutPositions[layoutKey]) {
                this.forceLayoutPositions[layoutKey] = {};
            }
            
            // Validate inputs
            if (!circles || !Array.isArray(circles)) {
                circles = [];
            }
            if (!dyads || !Array.isArray(dyads)) {
                dyads = [];
            }
            
            // Initialize positions in a circle (starting point)
            const initialPositions = {};
            const theta = 2 * Math.PI / n;
            for (let i = 0; i < n; i++) {
                if (!this.forceLayoutPositions[layoutKey][i]) {
                    initialPositions[i] = {
                        x: centerX + baseRadius * Math.cos(theta * i),
                        y: centerY + baseRadius * Math.sin(theta * i),
                        vx: 0, // velocity x
                        vy: 0  // velocity y
                    };
                } else {
                    // Keep existing position but reset velocity
                    initialPositions[i] = {
                        x: this.forceLayoutPositions[layoutKey][i].x,
                        y: this.forceLayoutPositions[layoutKey][i].y,
                        vx: 0,
                        vy: 0
                    };
                }
            }
            
            // Build connection graph from circles and dyads
            const connections = new Map();
            // Add connections from circles
            circles.forEach(circle => {
                for (let i = 0; i < circle.length; i++) {
                    for (let j = i + 1; j < circle.length; j++) {
                        const a = circle[i];
                        const b = circle[j];
                        if (!connections.has(a)) connections.set(a, new Set());
                        if (!connections.has(b)) connections.set(b, new Set());
                        connections.get(a).add(b);
                        connections.get(b).add(a);
                    }
                }
            });
            // Add connections from dyads
            dyads.forEach(dyad => {
                if (dyad.length === 2) {
                    const a = dyad[0];
                    const b = dyad[1];
                    if (!connections.has(a)) connections.set(a, new Set());
                    if (!connections.has(b)) connections.set(b, new Set());
                    connections.get(a).add(b);
                    connections.get(b).add(a);
                }
            });
            
            // Force simulation parameters
            const iterations = 150; // Increased iterations for better layout
            
            // Adaptive force parameters based on circle structure
            // Detect if we have a single large circle (high tolerance values)
            const circleCount = circles.length;
            const largestCircleSize = circles.length > 0 ? Math.max(...circles.map(c => c.length)) : 0;
            const isSingleLargeCircle = circleCount === 1 && largestCircleSize >= n * 0.8;
            
            // Increase optimal distance more when there's a single large circle
            let distanceMultiplier = 1.5; // Default multiplier
            if (isSingleLargeCircle) {
                distanceMultiplier = 1.8; // More space for single large circles
            } else if (circleCount === 1 && largestCircleSize > 0) {
                distanceMultiplier = 1.65; // Moderate increase
            }
            
            // Increase optimal distance to spread nodes further apart
            const k = Math.sqrt((centerX * centerY) / n) * distanceMultiplier;
            const repulsionStrength = k * k * 1.2; // Increased repulsion force strength
            const attractionStrength = 0.008; // Slightly reduced attraction to allow more spread
            const damping = 0.85; // Slightly reduced damping for more movement
            
            // Run simulation
            const positions = { ...initialPositions };
            
            for (let iter = 0; iter < iterations; iter++) {
                // Calculate forces
                const forces = {};
                for (let i = 0; i < n; i++) {
                    forces[i] = { fx: 0, fy: 0 };
                }
                
                // Repulsion forces (all nodes repel each other)
                for (let i = 0; i < n; i++) {
                    for (let j = i + 1; j < n; j++) {
                        const dx = positions[i].x - positions[j].x;
                        const dy = positions[i].y - positions[j].y;
                        const dist = Math.hypot(dx, dy) || 1; // Avoid division by zero
                        
                        // Coulomb repulsion
                        const force = repulsionStrength / (dist * dist);
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        forces[i].fx += fx;
                        forces[i].fy += fy;
                        forces[j].fx -= fx;
                        forces[j].fy -= fy;
                    }
                }
                
                // Attraction forces (connected nodes attract each other)
                connections.forEach((neighbors, node) => {
                    neighbors.forEach(neighbor => {
                        const dx = positions[neighbor].x - positions[node].x;
                        const dy = positions[neighbor].y - positions[node].y;
                        const dist = Math.hypot(dx, dy) || 1;
                        
                        // Hooke attraction (towards optimal distance k)
                        const force = (dist - k) * attractionStrength;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        
                        forces[node].fx += fx;
                        forces[node].fy += fy;
                        forces[neighbor].fx -= fx;
                        forces[neighbor].fy -= fy;
                    });
                });
                
                // Center attraction (keep nodes near center)
                const centerAttraction = 0.001;
                for (let i = 0; i < n; i++) {
                    const dx = centerX - positions[i].x;
                    const dy = centerY - positions[i].y;
                    forces[i].fx += dx * centerAttraction;
                    forces[i].fy += dy * centerAttraction;
                }
                
                // Update positions
                // Calculate adaptive margin based on circle structure
                const circleCount = circles.length;
                const largestCircleSize = circles.length > 0 ? Math.max(...circles.map(c => c.length)) : 0;
                const isSingleLargeCircle = circleCount === 1 && largestCircleSize >= n * 0.8;
                // Use smaller margin for single large circles to allow more spread
                const margin = isSingleLargeCircle ? 50 : 60;
                
                for (let i = 0; i < n; i++) {
                    // Update velocity
                    positions[i].vx = (positions[i].vx + forces[i].fx) * damping;
                    positions[i].vy = (positions[i].vy + forces[i].fy) * damping;
                    
                    // Update position
                    positions[i].x += positions[i].vx;
                    positions[i].y += positions[i].vy;
                    
                    // Keep within canvas bounds
                    positions[i].x = Math.max(margin, Math.min(this.width - margin, positions[i].x));
                    positions[i].y = Math.max(margin, Math.min(this.height - margin, positions[i].y));
                }
            }
            
            // Store final positions (without velocity)
            for (let i = 0; i < n; i++) {
                this.forceLayoutPositions[layoutKey][i] = {
                    x: positions[i].x,
                    y: positions[i].y
                };
            }
            
            this.forceLayoutInitialized = true;
        },
        /**
         * Navigation Methods
         */
        waiting_room() {
            window.location.href = '/waiting-room2/';
        },
        getTotalSafeConnections() {
            // Calculate total safe connections (sum of all safe circles available to all team members)
            const entry = this.circles.circles[this.current] || { circle_count: {} };
            const circle_count = entry.circle_count || {};
            return Object.values(circle_count).reduce((s, v) => s + v, 0);
        },
        /**
         * Tolerance Window Value Methods
         * These methods calculate the minimum, maximum, and optimal tolerance window values
         */
        getValue1() { 
            // Returns the first (lowest) tolerance value where safecircles exist
            for (const key in this.circles.circles) return key; 
        },
        getValue2() {
            // Returns the highest tolerance value where safecircles exist
            let maxKey = -Infinity;
            for (const key in this.circles.circles) maxKey = Math.max(maxKey, parseInt(key));
            return maxKey;
        },
        getMinTolerance() {
            /**
             * Returns the minimum tolerance value, considering both safecircles and in-groups.
             * If in-groups exist at lower tolerance values, returns the lowest in-group tolerance.
             * Otherwise, returns the lowest safecircle tolerance - 1.
             */
            // Find the lowest tolerance value where in-groups exist
            // If no in-groups exist, return getValue1()-1 (lowest safecircle value - 1)
            const inGroups = this.inGroups || [];
            if (inGroups.length === 0) {
                return this.getValue1() - 1;
            }
            
            // Find the minimum tolerance value from all in-groups
            let minTolerance = Infinity;
            inGroups.forEach(group => {
                if (group.tolerance !== undefined && group.tolerance < minTolerance) {
                    minTolerance = group.tolerance;
                }
            });
            
            // If we found a lower value than getValue1()-1, use it
            // Otherwise, use getValue1()-1 as the minimum
            const safecircleMin = this.getValue1() - 1;
            return Math.min(minTolerance, safecircleMin);
        },
        getValue3() {
            const pCount = this.circles.players.length;
            return Object.keys(this.circles.circles)
                .map(k => parseInt(k)).reverse()
                .find(k => Object.keys(this.circles.circles[k].circle_count).length <= pCount - 1);
        },
        getValue4() {
            let maxSum = -Infinity, best = -1;
            for (const key in this.circles.circles) {
                const sum = Object.values(this.circles.circles[key].circle_count)
                              .reduce((s, e) => s + e, 0);
                if (sum > maxSum) { maxSum = sum; best = key; }
            }
            return best;
           },
           
           /**
            * Safecircle Data Methods
            * Methods for retrieving and formatting safecircle information
            */
           getCircles() {
            const entry = this.circles.circles[this.current] || {};
            return (entry.circles || []).map(group => group.map(i => this.circles.players[i]).join(' '));
        },
           getCirclesDetailed() {
               const entry = this.circles.circles[this.current] || {};
               const circles = entry.circles || [];
               const circle_count = entry.circle_count || {};
               const colors = ['#fa5252', '#ff8c00', '#9FE2BF', '#52CEEC', '#9b59b6', '#E29635', '#3b4252'];
               
               // Calculate maxCount to identify integrators
               const maxCount = Math.max(0, ...Object.values(circle_count));
               
               return circles.map((group, idx) => {
                   const members = group.map(i => {
                       const count = circle_count[i] || 0;
                       const isTop = count === maxCount && maxCount > 0;
                       return {
                           name: this.circles.players[i],
                           avatar: this.players[this.circles.players[i]] || '',
                           count: count,
                           isIntegrator: isTop
                       };
                   });
                   
                   return {
                       members: members,
                       memberCount: members.length,
                       color: colors[idx % colors.length]
                   };
               });
           },
           /**
            * Visual Styling Methods
            */
           getSliderGradientBackgroundStyle() {
               /**
                * Creates a gradient background for the tolerance window slider.
                * - Red for low values (< 16): indicates high stress
                * - Green for optimal values (>= 16): indicates safe zone
                * - White for very high values: indicates potential groupthink
                */
               const min = this.getMinTolerance();
               const max = this.getValue2();
               const threshold = 16; // Value below which it transitions to red
               
               // Calculate percentage position of threshold (16)
               const thresholdPercent = ((threshold - min) / (max - min)) * 100;
               
               // Colors: red (low, < 16) -> green (main, >= 16) -> white (high)
               const redColor = '#fa5252';
               const greenColor = '#9FE2BF';
               const whiteColor = '#FFFFFF';
               
               // Create gradient: 
               // - Left (low values, < 16): red transitioning to green at 16
               // - Right (high values): green transitioning to white
               // The majority should be green
               return {
                   background: `linear-gradient(to right, ${redColor} 0%, ${greenColor} ${thresholdPercent}%, ${greenColor} 85%, ${whiteColor} 100%)`
               };
           },
           /**
            * UI Interaction Methods
            */
           /**
            * Safely set tolerance window value, ensuring canvas updates
            * Cancels any running animation and forces immediate redraw
            * @param {number} newValue - The new tolerance window value
            */
           setToleranceValue(newValue) {
               // Cancel any running animation
               if (this.isAnimating) {
                   console.log('Cancelling animation to set new value:', newValue);
                   this.isAnimating = false;
                   if (this.animationFrame) {
                       clearTimeout(this.animationFrame);
                       this.animationFrame = null;
                   }
               }
               
               // Clamp value to valid range
               const min = this.getMinTolerance();
               const max = this.getValue2();
               const clampedValue = Math.max(min, Math.min(max, newValue));
               
               // Set the value - this will trigger the watcher
               this.current = clampedValue;
               
               // Force immediate redraw to ensure canvas updates
               this.$nextTick(() => {
                   if (this.$refs.canvas) {
                       this.redraw();
                   }
               });
           },
           /**
            * Check if there are in-groups at the minimum tolerance value
            * @returns {boolean} True if in-groups exist at lower tolerance values than the first safecircle
            */
           hasInGroupsAtMin() {
               const inGroups = this.inGroups || [];
               if (inGroups.length === 0) {
                   return false;
               }
               
               const firstSafecircle = this.getValue1();
               
               // Check if any in-group has a tolerance value lower than the first safecircle
               return inGroups.some(group => {
                   if (group.tolerance !== undefined) {
                       return group.tolerance < firstSafecircle;
                   }
                   return false;
               });
           },
           hideReadingHelp() {
               /**
                * Hides the reading help section and sets tolerance to the minimum available value.
                * This includes in-groups if they exist at lower tolerance values than the first safecircle.
                */
               const section = document.getElementById('reading-help-section');
               if (section) {
                   section.style.display = 'none';
               }
               // Use getMinTolerance() to include in-groups if they exist at lower values
               // This ensures the button shows and sets the same value
               this.setToleranceValue(this.getMinTolerance());
           },
           hideMaxValueHelp() {
               /**
                * Hides the max value help section and sets tolerance to highest value.
                */
               const section = document.getElementById('max-value-help-section');
               if (section) {
                   section.style.display = 'none';
               }
               // Use setToleranceValue to ensure canvas updates
               this.setToleranceValue(this.getValue2());
           },
           
           /**
            * Animation Methods
            * Provides smooth transitions when tolerance window changes
            */
           animateTransition(fromVal, toVal) {
               // Don't animate if values are the same
               if (fromVal === toVal) {
                   console.log('Skipping animation: fromVal === toVal (', fromVal, ')');
                   return;
               }
               
               if (this.isAnimating) {
                   console.log('Animation already in progress, skipping');
                   return;
               }
               this.isAnimating = true;
               this._animationStartTime = Date.now();
               console.log('Starting animation from', fromVal, 'to', toVal);
               
               const steps = 20; // Number of animation frames
               const duration = 300; // Animation duration in ms
               const stepTime = duration / steps;
               let currentStep = 0;
               const self = this;
               
               const animate = function() {
                   // Check if animation was cancelled
                   if (!self.isAnimating || !self.animationFrame) {
                       console.log('Animation cancelled, stopping');
                       return;
                   }
                   
                   if (currentStep >= steps) {
                       self.current = toVal;
                       self.isAnimating = false;
                       self._animationStartTime = 0;
                       self.animationFrame = null;
                       console.log('Animation completed, final value:', toVal);
                       // Ensure canvas is redrawn after animation completes
                       self.$nextTick(() => {
                           if (self.$refs.canvas) {
                               self.redraw();
                           }
                       });
                       return;
                   }
                   
                   // Interpolate between fromVal and toVal
                   const progress = currentStep / steps;
                   // Use easing function for smoother animation
                   const eased = self.easeInOutCubic(progress);
                   const interpolated = Math.round(fromVal + (toVal - fromVal) * eased);
                   
                   self.current = interpolated;
                   currentStep++;
                   self.redraw();
                   self.animationFrame = setTimeout(function() {
                       requestAnimationFrame(animate);
                   }, stepTime);
               };
               
               animate();
           },
           easeInOutCubic(t) {
               return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
           },
           /**
            * Keyboard Navigation
            * Arrow keys: Change tolerance window
            * Space: Toggle between canvas and overview view
            */
          setupKeyboardShortcuts() {
              // Remove existing listener if any to prevent duplicates
              if (this._keyboardHandler) {
                  document.removeEventListener('keydown', this._keyboardHandler, true);
                  this._keyboardHandler = null;
              }
              
              // Create a bound handler function with debouncing to prevent multiple rapid calls
              const self = this;
              let lastKeyTime = 0;
              const DEBOUNCE_MS = 50; // Prevent rapid-fire key events
              
              this._keyboardHandler = function(e) {
                  // Debounce rapid key presses
                  const now = Date.now();
                  if (e.key && (e.key.startsWith('Arrow') || e.key === ' ')) {
                      if (now - lastKeyTime < DEBOUNCE_MS) {
                          console.log('Debouncing key press:', e.key);
                          return;
                      }
                      lastKeyTime = now;
                  }
                  
                  // Debug: Log all arrow key presses
                  if (e.key && (e.key.startsWith('Arrow') || e.key === ' ')) {
                      console.log('Key pressed:', e.key, 'Target:', e.target.tagName, 'Current value:', self.current);
                  }
                  
                  // Don't trigger if user is typing in an input field
                  if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                      console.log('Ignoring key press in input/textarea');
                      return;
                  }
                  
                  // Always allow keyboard navigation - animation will be cancelled in switch statement if needed
                  
                  const min = self.getMinTolerance(); // Use minimum tolerance (including in-groups)
                  const max = self.getValue2();
                  
                  switch(e.key) {
                      case 'ArrowLeft':
                      case 'ArrowUp':
                          e.preventDefault();
                          e.stopPropagation();
                          
                          // Cancel any ongoing animation immediately
                          if (self.isAnimating && self.animationFrame) {
                              clearTimeout(self.animationFrame);
                              self.animationFrame = null;
                              console.log('Cancelled ongoing animation');
                          }
                          // Temporarily disable animation for immediate response
                          const wasAnimating = self.isAnimating;
                          self.isAnimating = true; // Temporarily set to true to prevent watch from triggering animation
                          self._animationStartTime = 0;
                          
                          const currentBeforeLeft = self.current;
                          console.log('Arrow left/up pressed, current:', currentBeforeLeft, 'min:', min);
                          if (currentBeforeLeft > min) {
                              const newValue = Math.max(min, currentBeforeLeft - 1);
                              console.log('Setting current to:', newValue, 'from:', currentBeforeLeft);
                              
                              // Use setToleranceValue for consistent behavior
                              self.setToleranceValue(newValue);
                          } else {
                              // Re-enable animation if no change
                              self.isAnimating = wasAnimating;
                          }
                          break;
                      case 'ArrowRight':
                      case 'ArrowDown':
                          e.preventDefault();
                          e.stopPropagation();
                          
                          // Cancel any ongoing animation immediately
                          if (self.isAnimating && self.animationFrame) {
                              clearTimeout(self.animationFrame);
                              self.animationFrame = null;
                              console.log('Cancelled ongoing animation');
                          }
                          // Temporarily disable animation for immediate response
                          self.isAnimating = true; // Temporarily set to true to prevent watch from triggering animation
                          self._animationStartTime = 0;
                          
                          const currentBeforeRight = self.current;
                          console.log('Arrow right/down pressed, current:', currentBeforeRight, 'max:', max);
                          if (currentBeforeRight < max) {
                              const newValue = Math.min(max, currentBeforeRight + 1);
                              console.log('Setting current to:', newValue, 'from:', currentBeforeRight);
                              
                              // Use setToleranceValue for consistent behavior
                              self.setToleranceValue(newValue);
                          } else {
                              // Re-enable animation if no change
                              self.isAnimating = false;
                          }
                          break;
                      case ' ':
                          e.preventDefault();
                          e.stopPropagation();
                          console.log('Space pressed, toggling view');
                          self.toggleView();
                          break;
                  }
              };
              
              // Add the event listener with capture phase to ensure it runs early
              document.addEventListener('keydown', this._keyboardHandler, true);
              
              console.log('Keyboard shortcuts initialized, handler bound to:', this._keyboardHandler);
          },
           /**
            * Handle slider input events (while dragging)
            * Ensures immediate canvas update for responsive feedback
            */
           handleSliderInput(event) {
               // Cancel any running animation for immediate response
               if (this.isAnimating) {
                   this.isAnimating = false;
                   if (this.animationFrame) {
                       clearTimeout(this.animationFrame);
                       this.animationFrame = null;
                   }
               }
               // Get the new value from the slider
               const newValue = parseInt(event.target.value);
               // Update current value if it changed (v-model should handle this, but ensure it's set)
               if (newValue !== this.current) {
                   this.current = newValue;
               }
               // Force immediate redraw for responsive slider feedback
               // Don't wait for watcher - redraw immediately
               if (this.$refs.canvas) {
                   this.redraw();
               } else {
                   // If canvas not ready, wait for next tick
                   this.$nextTick(() => {
                       if (this.$refs.canvas) {
                           this.redraw();
                       }
                   });
               }
           },
           /**
            * Handle slider change events (when released/clicked)
            * Ensures final canvas update after slider interaction
            */
           handleSliderChange(event) {
               const newValue = parseInt(event.target.value);
               // Ensure value is set (v-model should handle this)
               if (newValue !== this.current) {
                   this.current = newValue;
               }
               // Ensure final redraw after slider interaction completes
               this.$nextTick(() => {
                   if (this.$refs.canvas) {
                       this.redraw();
                   }
               });
           },
           /**
            * Decrease tolerance value (for left arrow button)
            */
           decreaseTolerance() {
               const min = this.getMinTolerance();
               if (this.current > min) {
                   this.setToleranceValue(this.current - 1);
               }
           },
           /**
            * Increase tolerance value (for right arrow button)
            */
           increaseTolerance() {
               const max = this.getValue2();
               if (this.current < max) {
                   this.setToleranceValue(this.current + 1);
               }
           },
           toggleView() {
               // Cycle through: canvas -> expanded -> canvas
               if (this.viewMode === 'canvas') {
                   this.viewMode = 'expanded';
               } else if (this.viewMode === 'expanded') {
                   this.viewMode = 'canvas';
               } else {
                   // If in overview mode, go to canvas
                   this.viewMode = 'canvas';
               }
               
               // Recalculate canvas size based on new view mode
               this.calculateOptimalCanvasSize();
               
               // Close player detail when toggling
               if (this.showPlayerDetail) {
                   this.closePlayerDetail();
               }
               
               // Redraw canvas with new dimensions
               this.$nextTick(() => {
                   if (this.$refs.canvas) {
                       this.$refs.canvas.width = this.width;
                       this.$refs.canvas.height = this.height;
                       this.redraw();
                   }
               });
           },
           // Player detail view methods
           setupCanvasClickHandlers() {
               const canvas = this.$refs.canvas;
               if (!canvas) return;
               
               canvas.addEventListener('click', (e) => {
                   const rect = canvas.getBoundingClientRect();
                   const x = e.clientX - rect.left;
                   const y = e.clientY - rect.top;
                   
                   // Check if click is on a player avatar
                   const clickedPlayer = this.getPlayerAtPosition(x, y);
                   if (clickedPlayer !== null) {
                       this.showPlayerDetailView(clickedPlayer);
                   }
               });
               
               // Add cursor and visual feedback on hover over players
               let hoveredPlayer = null;
               
               canvas.addEventListener('mousemove', (e) => {
                   const rect = canvas.getBoundingClientRect();
                   const x = e.clientX - rect.left;
                   const y = e.clientY - rect.top;
                   
                   const player = this.getPlayerAtPosition(x, y);
                   
                   if (player !== null) {
                       // Show question mark cursor
                       canvas.style.cursor = 'help';
                       
                       // Show visual question mark if not already shown
                       if (hoveredPlayer !== player) {
                           hoveredPlayer = player;
                           this.showQuestionMarkOverPlayer(player, x, y);
                       }
                       
                       // ‚úÖ HOVER: Highlight circles containing this player
                       if (this.hoveredPlayerIndex !== player) {
                           this.hoveredPlayerIndex = player;
                           this.redraw(); // Redraw with hover highlighting
                       }
                   } else {
                       // Reset cursor
                       canvas.style.cursor = 'default';
                       
                       // Hide question mark
                       if (hoveredPlayer !== null) {
                           hoveredPlayer = null;
                           this.hideQuestionMark();
                       }
                       
                       // ‚úÖ HOVER: Clear hover highlighting
                       if (this.hoveredPlayerIndex !== null) {
                           this.hoveredPlayerIndex = null;
                           this.redraw(); // Redraw without hover highlighting
                       }
                   }
               });
               
               canvas.addEventListener('mouseleave', () => {
                   canvas.style.cursor = 'default';
                   if (hoveredPlayer !== null) {
                       hoveredPlayer = null;
                       this.hideQuestionMark();
                   }
                   // ‚úÖ HOVER: Clear hover highlighting when mouse leaves canvas
                   if (this.hoveredPlayerIndex !== null) {
                       this.hoveredPlayerIndex = null;
                       this.redraw(); // Redraw without hover highlighting
                   }
               });
           },
           getPlayerAtPosition(x, y) {
               // Check each stored player position
               for (const [playerIndex, pos] of Object.entries(this.playerPositions)) {
                   const distance = Math.hypot(x - pos.x, y - pos.y);
                   // Clickable area: avatar size / 2 + some padding
                   const clickRadius = (pos.size / 2) + 10;
                   if (distance <= clickRadius) {
                       return parseInt(playerIndex);
                   }
               }
               return null;
           },
           showPlayerDetailView(playerIndex) {
               this.selectedPlayer = playerIndex;
               this.showPlayerDetail = true;
           },
           closePlayerDetail() {
               this.showPlayerDetail = false;
               this.selectedPlayer = null;
           },
           getPlayerDetails(playerIndex) {
               if (playerIndex === null || playerIndex === undefined) return null;
               
               const playerName = this.circles.players[playerIndex];
               const entry = this.circles.circles[this.current] || {};
               const circles = entry.circles || [];
               const circle_count = entry.circle_count || {};
               const maxCount = Math.max(0, ...Object.values(circle_count));
               
               // Find all circles this player is in
               const colors = ['#fa5252', '#ff8c00', '#9FE2BF', '#52CEEC', '#9b59b6', '#E29635', '#3b4252'];
               const playerCircles = circles
                   .map((circle, idx) => {
                       const memberDetails = circle.map(i => {
                           const memberName = this.circles.players[i];
                           const memberCount = circle_count[i] || 0;
                           const isMemberIntegrator = memberCount === maxCount && maxCount > 0;
                           return {
                               name: memberName,
                               avatar: this.players[memberName] || '',
                               safetyAnchor: this.anchors[memberName] || '',
                               isIntegrator: isMemberIntegrator,
                               isCurrentPlayer: i === playerIndex
                           };
                       });
                       return {
                           index: idx,
                           members: memberDetails,
                           includesPlayer: circle.includes(playerIndex),
                           color: colors[idx % colors.length]
                       };
                   })
                   .filter(c => c.includesPlayer);
               
               // Find in-groups this player is part of
               // First, create a set of pairs that are in safecircles at current tolerance
               const pairsInCurrentCircle = new Set();
               const currentCircles = circles || [];
               const currentDyads = entry.dyads || [];
               
               currentCircles.forEach(circle => {
                   for (let idx1 = 0; idx1 < circle.length; idx1++) {
                       for (let idx2 = idx1 + 1; idx2 < circle.length; idx2++) {
                           const pair = [Math.min(circle[idx1], circle[idx2]), Math.max(circle[idx1], circle[idx2])];
                           pairsInCurrentCircle.add(pair.join(','));
                       }
                   }
               });
               currentDyads.forEach(dyad => {
                   if (dyad.length === 2) {
                       const pair = [Math.min(dyad[0], dyad[1]), Math.max(dyad[0], dyad[1])];
                       pairsInCurrentCircle.add(pair.join(','));
                   }
               });
               
               // Filter in-groups: only show those NOT in safecircles at current tolerance
               const playerInGroups = (this.inGroups || [])
                   .filter(group => {
                       // Check if this player is part of the in-group
                       if (group.i !== playerIndex && group.j !== playerIndex) {
                           return false;
                       }
                       
                       // Show in-groups if current tolerance is within the range where this in-group exists
                       // In-groups exist from group.tolerance (min) to group.max_tolerance (max, if defined)
                       // Also show if current is the lowest available tolerance value (even if lower than group.tolerance)
                       // This allows in-groups detected below the first safecircle to still be visible
                       const minAvailableTolerance = this.getValue1(); // Lowest tolerance with safecircles
                       const isLowestTolerance = this.current === minAvailableTolerance;
                       
                       if (group.tolerance) {
                           // Check if current is within the valid range
                           const maxTolerance = group.max_tolerance || 999; // If no max, assume it continues
                           const isWithinRange = this.current >= group.tolerance && this.current <= maxTolerance;
                           
                           if (!isWithinRange && !isLowestTolerance) {
                               return false; // Don't show - current tolerance is outside the valid range for this in-group
                           }
                       }
                       
                       // Check if this pair is in a safecircle at current tolerance
                       const pairKey = [Math.min(group.i, group.j), Math.max(group.i, group.j)].join(',');
                       if (pairsInCurrentCircle.has(pairKey)) {
                           return false; // Don't show - they're in a safecircle now
                       }
                       
                       return true; // Show this in-group
                   })
                   .map(group => {
                       const otherIndex = group.i === playerIndex ? group.j : group.i;
                       const otherPlayerName = this.circles.players[otherIndex];
                       const currentPlayerName = this.circles.players[playerIndex];
                       
                       // Get integrator status for both players
                       const otherCount = circle_count[otherIndex] || 0;
                       const currentCount = circle_count[playerIndex] || 0;
                       const isOtherIntegrator = otherCount === maxCount && maxCount > 0;
                       const isCurrentIntegrator = currentCount === maxCount && maxCount > 0;
                       
                       // Create member details for both players in the in-group
                       const members = [
                           {
                               name: currentPlayerName,
                               avatar: this.players[currentPlayerName] || '',
                               safetyAnchor: this.anchors[currentPlayerName] || '',
                               isIntegrator: isCurrentIntegrator,
                               isCurrentPlayer: true
                           },
                           {
                               name: otherPlayerName,
                               avatar: this.players[otherPlayerName] || '',
                               safetyAnchor: this.anchors[otherPlayerName] || '',
                               isIntegrator: isOtherIntegrator,
                               isCurrentPlayer: false
                           }
                       ];
                       
                       return {
                           members: members,
                           otherPlayer: otherPlayerName,
                           avg_p1_to_p2: group.avg_p1_to_p2,
                           avg_p2_to_p1: group.avg_p2_to_p1,
                           similarity: group.similarity
                       };
                   });
               
               // Determine role
               const count = circle_count[playerIndex] || 0;
               const isIntegrator = count === maxCount && maxCount > 0;
               const isSolo = playerCircles.length === 0;
               const isInMultipleCircles = playerCircles.length > 1;
               
               let role = 'Team Member';
               if (isIntegrator) role = 'Integrator';
               else if (isSolo) role = 'Solo';
               else if (isInMultipleCircles) role = 'Bridge';
               
               return {
                   name: playerName,
                   avatar: this.players[playerName] || '',
                   safetyAnchor: this.anchors[playerName] || '',
                   circleCount: count,
                   role: role,
                   circles: playerCircles,
                   inGroups: playerInGroups,
                   isIntegrator: isIntegrator
               };
        },
        redraw() {
            const canvas = this.$refs.canvas;
            if (!canvas) {
                console.warn('Canvas ref not available yet');
                return;
            }
            // Ensure canvas dimensions match data
            if (canvas.width !== this.width || canvas.height !== this.height) {
                canvas.width = this.width;
                canvas.height = this.height;
            }
            const ctx    = canvas.getContext('2d');
            const { width, height } = this;

            const drawToken = Symbol('draw');
            this._drawToken = drawToken;

            // Clear canvas with white background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, width, height);
            ctx.clearRect(0, 0, width, height);
            
            // text
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // core data
            const players = this.circles.players;
            const avatars = this.players;
            const anchors = this.anchors || {};
            const entry = this.circles.circles[this.current] || { circles: [], circle_count: {} };
            const { circles, circle_count } = entry;
            
            // Get hovered player index for highlighting
            const hoveredIndex = this.hoveredPlayerIndex;
            
            // Find all players connected to the hovered player (in the same circles)
            const connectedPlayers = new Set();
            if (hoveredIndex !== null) {
                circles.forEach(circle => {
                    if (circle.includes(hoveredIndex)) {
                        // Add all players in this circle to connectedPlayers
                        circle.forEach(playerIndex => {
                            if (playerIndex !== hoveredIndex) {
                                connectedPlayers.add(playerIndex);
                            }
                        });
                    }
                });
            }
            const n = players.length;
            
            // Canvas size is fixed at 1000x1000, no need to recalculate
            const [cx, cy] = [width/2, height/2];
            const r0 = Math.min(width, height);
            const dR = 16;
            
            // Adaptive radius calculation based on circle structure
            // When there's only one large circle (high tolerance values), use more space
            const circleCount = circles.length;
            const largestCircleSize = circles.length > 0 ? Math.max(...circles.map(c => c.length)) : 0;
            const isSingleLargeCircle = circleCount === 1 && largestCircleSize >= n * 0.8; // 80% or more in one circle
            
            // Base radius factor scales with team size
            let baseRadiusFactor = Math.min(0.55, 0.4 + (n / 100)); // Scales from 0.4 to 0.55 for larger teams
            
            // Increase radius when there's only one large circle (high tolerance values)
            // This prevents avatars from being too close together
            if (isSingleLargeCircle) {
                // Use more space when all players are in one circle
                baseRadiusFactor = Math.min(0.65, 0.5 + (n / 80)); // Scales from 0.5 to 0.65
            } else if (circleCount === 1 && largestCircleSize > 0) {
                // Single circle but not all players - moderate increase
                baseRadiusFactor = Math.min(0.6, 0.45 + (n / 90));
            } else if (circleCount <= 2 && largestCircleSize >= n * 0.6) {
                // Few circles with large membership - slight increase
                baseRadiusFactor = Math.min(0.58, 0.42 + (n / 95));
            }
            
            const radiusFactor = baseRadiusFactor;
            const r1 = r0 * radiusFactor;
            const theta = 2 * Math.PI / n;

            // Calculate total safe connections (sum of all safe circles available to all team members)
            // This is now displayed in the control area above, not in the canvas
            ctx.font = '18px Lato-Regular, sans-serif';

            // positions
            const round = v => Math.round(v * 1e5) / 1e5;

            // top sizing
            const maxCount = Math.max(0, ...Object.values(circle_count));
            const baseSize = 64;

            // Calculate actual avatar positions (before drawing, so we can use them for safecircles and in-group lines)
            const avatarPositions = {};
            
            // ‚úÖ Force-Directed Layout: Calculate positions based on connections
            const dyads = entry.dyads || [];
            if (this.useForceLayout && n <= 20) {
                // Initialize or update force layout positions
                // Use a key that includes both circles and dyads to detect changes
                const layoutKey = `${n}_${this.current}`;
                if (!this.forceLayoutPositions[layoutKey] || Object.keys(this.forceLayoutPositions[layoutKey]).length === 0) {
                    this.calculateForceLayout(n, circles, dyads, cx, cy, r1);
                    // Ensure positions are calculated before proceeding
                    if (!this.forceLayoutPositions[layoutKey] || Object.keys(this.forceLayoutPositions[layoutKey]).length === 0) {
                        // Fallback: use circular layout if force layout failed
                        console.warn('Force layout calculation failed, using circular layout');
                    }
                }
                
                // Use force-directed positions
                players.forEach((name, i) => {
                    const pos = this.forceLayoutPositions[layoutKey] && this.forceLayoutPositions[layoutKey][i];
                    if (pos) {
                        avatarPositions[i] = { x: pos.x, y: pos.y };
                    } else {
                        // Fallback to circular layout if position not found
                        const count = circle_count[i] || 0;
                        const isTop = count === maxCount && maxCount > 0;
                        const radius = isTop ? r1 * 0.75 : r1;
                        avatarPositions[i] = { 
                            x: cx + radius * Math.cos(theta * i),
                            y: cy + radius * Math.sin(theta * i)
                        };
                    }
                });
            } else {
                // Use circular layout (original)
                players.forEach((name, i) => {
                    const count = circle_count[i] || 0;
                    const isTop = count === maxCount && maxCount > 0;
                    const radius = isTop ? r1 * 0.75 : r1;
                    const px = cx + radius * Math.cos(theta * i);
                    const py = cy + radius * Math.sin(theta * i);
                    avatarPositions[i] = { x: px, y: py };
                });
            }
            
            // Create boundary arrays from actual avatar positions (for safecircle drawing)
            // Add dR offset to position the circle edge outside the avatar
            // In expanded mode, allow content to extend beyond normal bounds
            const padding = this.viewMode === 'expanded' ? this.expandedPadding : 0;
            const margin = 50; // Base margin to keep circles within canvas
            // In expanded mode, use larger bounds to allow content to extend
            const maxX = this.viewMode === 'expanded' ? width - margin : width - margin;
            const maxY = this.viewMode === 'expanded' ? height - margin : height - margin;
            const minX = margin;
            const minY = margin;
            
            const boundaryX = players.map((_, i) => {
                const pos = avatarPositions[i];
                const dx = pos.x - cx;
                const dy = pos.y - cy;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    // Move dR pixels further out from the avatar center
                    const boundaryXValue = cx + (dx / dist) * (dist + dR);
                    // In expanded mode, allow boundaries to extend into padding area
                    if (this.viewMode === 'expanded') {
                        return Math.max(minX - padding, Math.min(maxX + padding, boundaryXValue));
                    }
                    // Clamp to canvas bounds in normal mode
                    return Math.max(minX, Math.min(maxX, boundaryXValue));
                }
                const fallbackX = pos.x + dR;
                return this.viewMode === 'expanded' 
                    ? Math.max(minX - padding, Math.min(maxX + padding, fallbackX))
                    : Math.max(minX, Math.min(maxX, fallbackX));
            });
            const boundaryY = players.map((_, i) => {
                const pos = avatarPositions[i];
                const dx = pos.x - cx;
                const dy = pos.y - cy;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    // Move dR pixels further out from the avatar center
                    const boundaryYValue = cy + (dy / dist) * (dist + dR);
                    // In expanded mode, allow boundaries to extend into padding area
                    if (this.viewMode === 'expanded') {
                        return Math.max(minY - padding, Math.min(maxY + padding, boundaryYValue));
                    }
                    // Clamp to canvas bounds in normal mode
                    return Math.max(minY, Math.min(maxY, boundaryYValue));
                }
                const fallbackY = pos.y + dR;
                return this.viewMode === 'expanded'
                    ? Math.max(minY - padding, Math.min(maxY + padding, fallbackY))
                    : Math.max(minY, Math.min(maxY, fallbackY));
            });

            // helpers
            const calc=(x1,y1,x2,y2)=>[Math.hypot(x2-x1,y2-y1),Math.atan2(y2-y1,x2-x1)];
            const moveP=(xo,yo,xp,yp)=>{
            let [d,a]=calc(xo,yo,xp,yp);
            d+=dR;
            return [
                round(xo + d * Math.cos(a)),
                round(yo + d * Math.sin(a))
            ];
            };

            // draw safe circles
            const colors=['#FF4444','#FF8800','#44AA44','#4488FF','#AA44FF','#FFDD00','#333333'];
            // Track which players are in circles for green dot placement
            const playersInCircles = new Set();
            circles.forEach((members,idx)=>{
                members.forEach(i => playersInCircles.add(i));
                
                // ‚úÖ HOVER: If a player is hovered, emphasize circles that contain that player
                const isHoveredCircle = hoveredIndex !== null && members.includes(hoveredIndex);
                if (hoveredIndex !== null && !isHoveredCircle) {
                    // Draw non-hovered circles with very low opacity
                    ctx.globalAlpha = 0.15;
                } else {
                    ctx.globalAlpha = 1.0;
                }
                
                const circleColor = colors[idx%colors.length];
                
                // Calculate center for circle drawing
                let x0=0,y0=0; members.forEach(i=>(x0+=boundaryX[i],y0+=boundaryY[i])); x0/=members.length; y0/=members.length;
                
                // Reset alpha after drawing this circle
                ctx.globalAlpha = 1.0;
                
                // Check if all players are in this single circle (perfect circle case)
                const isAllPlayersCircle = circles.length === 1 && members.length === n;
                
                if (isAllPlayersCircle) {
                    // Draw a perfect circle that encompasses all players
                    // Calculate radius: distance from center to farthest boundary point + dR
                    let maxRadius = 0;
                    members.forEach(i => {
                        const dist = Math.hypot(boundaryX[i] - x0, boundaryY[i] - y0);
                        maxRadius = Math.max(maxRadius, dist);
                    });
                    const circleRadius = maxRadius + dR;
                    
                    // Draw perfect circle outline
                    ctx.strokeStyle = circleColor; 
                    ctx.lineWidth = isHoveredCircle ? 5 : 3; // Thicker outline when hovered
                    ctx.setLineDash([]); 
                    ctx.beginPath();
                    ctx.arc(x0, y0, circleRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else {
                    // Draw using Bezier curves (existing logic)
                    // Calculate average distance between points for dynamic hr adjustment
                    let totalDistance = 0;
                    let distanceCount = 0;
                    members.forEach((pt,j)=>{
                        const nextIdx=members[(j+1)%members.length];
                        const [tx,ty]=moveP(x0,y0,boundaryX[members[j]],boundaryY[members[j]]);
                        const [nx,ny]=moveP(x0,y0,boundaryX[nextIdx],boundaryY[nextIdx]);
                        const dist = Math.hypot(nx - tx, ny - ty);
                        totalDistance += dist;
                        distanceCount++;
                    });
                    const avgDistance = distanceCount > 0 ? totalDistance / distanceCount : 200;
                    
                    // Base handle radius (increased from 120 to 180 for rounder appearance)
                    const baseHr = 180;
                    
                    ctx.strokeStyle = circleColor; 
                    ctx.lineWidth = isHoveredCircle ? 5 : 3; // Thicker outline when hovered
                    ctx.setLineDash([]); 
                    ctx.beginPath();
                    members.forEach((pt,j)=>{
                        const nextIdx=members[(j+1)%members.length];
                        const [tx,ty,,,th1]=calcEdge(j,members,x0,y0,boundaryX,boundaryY,moveP);
                        const [nx,ny,,,th2]=calcEdge((j+1)%members.length,members,x0,y0,boundaryX,boundaryY,moveP);
                            
                            // Dynamic hr: adjust based on distance between points
                            // For larger distances, use larger hr; for smaller distances, use smaller hr
                            const segmentDistance = Math.hypot(nx - tx, ny - ty);
                            const hr = baseHr * (segmentDistance / avgDistance);
                            
                        const c1x = round(tx + hr * Math.cos(th1 - Math.PI / 2));
                        const c1y = round(ty + hr * Math.sin(th1 - Math.PI / 2));
                        const c2x = round(nx + hr * Math.cos(th2 + Math.PI / 2));
                        const c2y = round(ny + hr * Math.sin(th2 + Math.PI / 2));
                        if(!j)ctx.moveTo(tx,ty);
                        ctx.bezierCurveTo(c1x,c1y,c2x,c2y,nx,ny);
                    }); 
                    ctx.stroke();
                }
            });

            // ‚úÖ draw dyads (real safe dyads from backend)
            // Note: dyads is already declared above (line 1489)
            dyads.forEach(pair => {
                const [i, j] = pair;
                
                // Use actual avatar positions (not boundary positions)
                // This accounts for integrators being larger and closer to center
                const pos1 = avatarPositions[i];
                const pos2 = avatarPositions[j];
                
                if (!pos1 || !pos2) {
                    return; // Skip if positions not calculated yet
                }
                
                const x1 = pos1.x;
                const y1 = pos1.y;
                const x2 = pos2.x;
                const y2 = pos2.y;

                ctx.beginPath();
                ctx.setLineDash([6, 4]); // dotted style for dyads
                ctx.strokeStyle = 'gold';
                ctx.lineWidth = 2;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.setLineDash([]);
            });

            // ‚úÖ draw in-groups (dotted golden lines for similar high-voting pairs not in safecircles)
            // Only draw if the pair is NOT in a safecircle at the current tolerance window value
            const inGroups = this.inGroups || [];
            const currentEntry = this.circles.circles[this.current] || { circles: [], dyads: [] };
            const currentCircles = currentEntry.circles || [];
            const currentDyads = currentEntry.dyads || [];
            
            // Create a set of pairs that are in safecircles at current tolerance
            const pairsInCurrentCircle = new Set();
            currentCircles.forEach(circle => {
                for (let idx1 = 0; idx1 < circle.length; idx1++) {
                    for (let idx2 = idx1 + 1; idx2 < circle.length; idx2++) {
                        const pair = [Math.min(circle[idx1], circle[idx2]), Math.max(circle[idx1], circle[idx2])];
                        pairsInCurrentCircle.add(pair.join(','));
                    }
                }
            });
            currentDyads.forEach(dyad => {
                if (dyad.length === 2) {
                    const pair = [Math.min(dyad[0], dyad[1]), Math.max(dyad[0], dyad[1])];
                    pairsInCurrentCircle.add(pair.join(','));
                }
            });
            
            inGroups.forEach(group => {
                const i = group.i;
                const j = group.j;
                const pairKey = [Math.min(i, j), Math.max(i, j)].join(',');
                
                // Show in-groups if current tolerance is within the range where this in-group exists
                // In-groups exist from group.tolerance (min) to group.max_tolerance (max, if defined)
                // Also show if current is the lowest available tolerance value (even if lower than group.tolerance)
                // This allows in-groups detected below the first safecircle to still be visible
                const minAvailableTolerance = this.getValue1(); // Lowest tolerance with safecircles
                const isLowestTolerance = this.current === minAvailableTolerance;
                
                if (group.tolerance) {
                    // Check if current is within the valid range
                    const maxTolerance = group.max_tolerance || 999; // If no max, assume it continues
                    const isWithinRange = this.current >= group.tolerance && this.current <= maxTolerance;
                    
                    if (!isWithinRange && !isLowestTolerance) {
                        return; // Don't draw - current tolerance is outside the valid range for this in-group
                    }
                }
                
                // Skip if this pair is in a safecircle at the current tolerance window
                if (pairsInCurrentCircle.has(pairKey)) {
                    return; // Don't draw - they're in a safecircle now
                }
                
                // Use actual avatar positions (not boundary positions)
                // This accounts for integrators being larger and closer to center
                const pos1 = avatarPositions[i];
                const pos2 = avatarPositions[j];
                
                if (!pos1 || !pos2) {
                    return; // Skip if positions not calculated yet
                }
                
                const x1 = pos1.x;
                const y1 = pos1.y;
                const x2 = pos2.x;
                const y2 = pos2.y;

                ctx.beginPath();
                ctx.setLineDash([8, 4]); // dotted style for in-groups (slightly longer dashes)
                ctx.strokeStyle = '#FFD700'; // golden color
                ctx.lineWidth = 2;
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.setLineDash([]);
            });



/*
                // dynamic golden pairs: aligned to players order
                const statusSides = players.map((name, idx) => {
                  // find the matching entry by name, or fall back by index
                  const entry = this.allResult.find(e => e.name === name);
                  return entry ? entry.statusSide : this.allResult[idx].statusSide;
                });
                const goldenCandidates = [];
                const threshold = Math.round(this.current);

                for (let i = 0; i < n; i++) {
                  for (let j = i + 1; j < n; j++) {
                    const diff = Math.abs(statusSides[i] - statusSides[j]);
                    if (diff - threshold <= 1e-6) {
                      goldenCandidates.push([i, j]);
                    }
                  }
                }

                const activeGolden = goldenCandidates.filter(pair =>
                  !circles.some(rc => pair.every(idx => rc.includes(idx)))
                );

                // üîí Stabilisiere Reihenfolge
                activeGolden.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
                // draw golden dotted

            activeGolden.forEach(members=>{
                let x0=0,y0=0; members.forEach(i=>(x0+=boundaryX[i],y0+=boundaryY[i])); x0/=members.length; y0/=members.length;
                ctx.strokeStyle='gold'; ctx.lineWidth=2; ctx.setLineDash([10,5]); ctx.beginPath();
                members.forEach((pt,j)=>{
                    const [tx,ty,,,th1]=calcEdge(j,members,x0,y0,boundaryX,boundaryY,moveP);
                    const idx2=(j+1)%members.length;
                    const [nx,ny,,,th2]=calcEdge(idx2,members,x0,y0,boundaryX,boundaryY,moveP);
                    const hr=120;
                    const c1x=tx+hr*Math.cos(th1-Math.PI/2), c1y=ty+hr*Math.sin(th1-Math.PI/2);
                    const c2x=nx+hr*Math.cos(th2+Math.PI/2), c2y=ny+hr*Math.sin(th2+Math.PI/2);
                    if(!j)ctx.moveTo(tx,ty);
                    ctx.bezierCurveTo(c1x,c1y,c2x,c2y,nx,ny);
                });
                ctx.stroke(); ctx.setLineDash([]); ctx.lineWidth=3;
            });
*/


            // draw players
            // Clear player positions for click detection
            this.playerPositions = {};
            players.forEach((name,i)=>{
                const count = circle_count[i]||0;
                const isTop = count===maxCount && maxCount>0;
                const size = isTop?Math.floor(baseSize*1.3):baseSize;
                // Use calculated avatar positions (from force layout or circular layout)
                const pos = avatarPositions[i];
                const px = pos.x;
                const py = pos.y;

                // Store player position for click detection
                this.playerPositions[i] = { x: px, y: py, size: size };

                const img = new Image(); img.src = avatars[name];
                const drawPerson = () => {
                    if (this._drawToken !== drawToken) return;
                    
                    // Draw green ring around avatar if this player is connected to hovered player
                    const isConnected = hoveredIndex !== null && connectedPlayers.has(i);
                    if (isConnected) {
                        ctx.strokeStyle = '#9FE2BF';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(px, py, size/2 + 3, 0, 2 * Math.PI);
                        ctx.stroke();
                    }
                    
                    ctx.drawImage(img, px-size/2, py-size/2, size, size);
                    ctx.fillStyle='black'; ctx.font='18px Lato-Regular, sans-serif';
                    const nameY = py+size/2+20;
                    // Draw name and safety anchor on the same line
                    const nameText = name;
                    const safetyAnchor = anchors[name];
                    // In expanded mode, allow text to extend further to prevent clipping
                    const maxTextWidth = this.viewMode === 'expanded' ? size + 150 : size + 80;
                    const maxTextWidthSimple = this.viewMode === 'expanded' ? size + 100 : size + 40;
                    if (safetyAnchor) {
                        // Combine name and safety anchor on one line
                        const combinedText = name + ' (' + safetyAnchor + ')';
                        ctx.fillText(combinedText, px, nameY, maxTextWidth);
                    } else {
                        ctx.fillText(nameText, px, nameY, maxTextWidthSimple);
                    }
                    const bubbleOffset=27, bx=px+bubbleOffset, by=py-bubbleOffset;
                    ctx.beginPath(); ctx.fillStyle=isTop ? '#9FE2BF' : '#FFFFFF'; ctx.strokeStyle='white'; ctx.lineWidth=2;
                    ctx.arc(bx,by,20,0,2*Math.PI); ctx.fill(); ctx.stroke();
                    ctx.fillStyle='black'; ctx.font='bold ' + (isTop ? 36 : 32) + 'px Lato-Bold, sans-serif';
                    ctx.textBaseline='middle'; ctx.fillText(count,bx,by); ctx.textBaseline='alphabetic';
                };
                if (img.complete) {
                    drawPerson();
                } else {
                    img.onload = drawPerson;
                }
            });

            // helper for edges
            function calcEdge(i2, members, x0, y0, bX, bY, moveF) {
                const prev = members[(i2 - 1 + members.length) % members.length];
                const nxt = members[(i2 + 1) % members.length];
                const [tx, ty] = moveF(x0, y0, bX[members[i2]], bY[members[i2]]);
                const [px, py] = moveF(x0, y0, bX[prev], bY[prev]);
                const [nx, ny] = moveF(x0, y0, bX[nxt], bY[nxt]);
                const a1 = Math.atan2(ny - ty, nx - tx);
                const a2 = Math.atan2(py - ty, px - tx);
                let th = (a1 + a2) / 2;
                if (th < a1) th += Math.PI;
                return [tx, ty, nx, ny, th];
            }
        },
        showQuestionMarkOverPlayer(playerIndex, mouseX, mouseY) {
            // Remove existing question mark
            this.hideQuestionMark();
            
            // Get player position
            const pos = this.playerPositions[playerIndex];
            if (!pos) return;
            
            // Create question mark element
            const questionMark = document.createElement('div');
            questionMark.id = 'player-question-mark';
            questionMark.textContent = '?';
            const topPos = pos.y - (pos.size / 2) - 35;
            questionMark.style.cssText = 'position: absolute; ' +
                'left: ' + pos.x + 'px; ' +
                'top: ' + topPos + 'px; ' +
                'font-size: 28px; ' +
                'font-weight: bold; ' +
                'color: #52CEEC; ' +
                'pointer-events: none; ' +
                'z-index: 1000; ' +
                'text-align: center; ' +
                'width: 36px; ' +
                'height: 36px; ' +
                'line-height: 36px; ' +
                'background-color: rgba(255, 255, 255, 0.95); ' +
                'border-radius: 50%; ' +
                'box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); ' +
                'transform: translateX(-50%);';
            
            // Add to canvas container (parent div)
            const canvas = this.$refs.canvas;
            if (canvas && canvas.parentElement) {
                canvas.parentElement.style.position = 'relative';
                canvas.parentElement.appendChild(questionMark);
                this._questionMarkElement = questionMark;
            }
        },
        hideQuestionMark() {
            if (this._questionMarkElement) {
                this._questionMarkElement.remove();
                this._questionMarkElement = null;
            } else {
                const existing = document.getElementById('player-question-mark');
                if (existing) {
                    existing.remove();
                }
            }
        }
    },
    watch: {
        viewMode(newVal, oldVal) {
            // When view mode changes, recalculate canvas size and redraw
            if (newVal !== oldVal) {
                this.calculateOptimalCanvasSize();
                this.$nextTick(() => {
                    if (this.$refs.canvas) {
                        this.$refs.canvas.width = this.width;
                        this.$refs.canvas.height = this.height;
                        this.redraw();
                    }
                });
            }
        },
        current(newVal, oldVal) {
            // Skip if value hasn't actually changed
            if (newVal === oldVal) {
                return;
            }
            
            // Reset force layout when tolerance window changes (circles may change)
            if (this.useForceLayout && oldVal !== undefined) {
                const n = this.circles.players.length;
                const oldKey = `${n}_${oldVal}`;
                // Clean up old positions (keep only last few to save memory)
                if (this.forceLayoutPositions[oldKey]) {
                    delete this.forceLayoutPositions[oldKey];
                }
            }
            
            // Cancel any running animation if a new value is set
            if (this.isAnimating && oldVal !== undefined) {
                console.log('Cancelling animation due to new value:', newVal);
                this.isAnimating = false;
                if (this.animationFrame) {
                    clearTimeout(this.animationFrame);
                    this.animationFrame = null;
                }
            }
            
            // Only animate if values actually changed and oldVal is defined (not initial load)
            // Don't animate if the change was very small (likely from slider dragging)
            // For slider interactions, always redraw immediately for responsive feedback
            const changeAmount = Math.abs(newVal - oldVal);
            const shouldAnimate = oldVal !== undefined && 
                                 changeAmount > 1 && 
                                 !this.isAnimating;
            
            if (shouldAnimate) {
                console.log('Watch triggered: animating from', oldVal, 'to', newVal);
                this.animateTransition(oldVal, newVal);
            } else {
                // On initial load, slider dragging (including step-by-step), or button clicks, redraw immediately
                // Ensure canvas ref is available before redraw
                // Force immediate redraw for slider interactions
                if (this.$refs.canvas) {
                    // Canvas is ready, redraw immediately
                    this.redraw();
                } else {
                    // Canvas not ready yet, wait for next tick
                    this.$nextTick(() => {
                        if (this.$refs.canvas) {
                            this.redraw();
                        } else {
                            // If canvas still not ready, try again after a short delay
                            setTimeout(() => {
                                if (this.$refs.canvas) {
                                    this.redraw();
                                }
                            }, 50);
                        }
                    });
                }
            }
        }
    }
});

    // Close initTeamPotential function
}

// Initialize when DOM is ready - this ensures json_script elements are loaded
// Prevent multiple initializations
if (!window.teamPotentialInitStarted) {
    window.teamPotentialInitStarted = true;
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            initTeamPotential();
            // Try to initialize AppGraph only if container exists (optional)
            setTimeout(initAppGraphInstance, 500);
        });
    } else {
        initTeamPotential();
        // Try to initialize AppGraph only if container exists (optional)
        setTimeout(initAppGraphInstance, 500);
    }
}

/**
 * Tooltip Utility Functions
 * Centralized tooltip initialization helpers to reduce code duplication
 */

/**
 * Initialize a simple tooltip with standard configuration
 * @param {string|HTMLElement} element - Element ID or element reference
 * @param {string|Function} content - Tooltip content or function that returns content
 * @param {Object} options - Additional tippy.js options
 */
function initSimpleTooltip(element, content, options = {}) {
    const el = typeof element === 'string' ? document.getElementById(element) : element;
    if (!el) return;
    
    // Remove existing tooltip if any
    if (el._tippy) {
        el._tippy.destroy();
    }
    
    try {
        tippy(el, {
            content: content,
            placement: options.placement || 'top',
            theme: options.theme || 'light',
            delay: options.delay || [200, 0],
            allowHTML: options.allowHTML !== undefined ? options.allowHTML : false,
            interactive: options.interactive !== undefined ? options.interactive : false,
            trigger: options.trigger || 'mouseenter focus',
            maxWidth: options.maxWidth || 400,
            animation: options.animation || 'fade',
            arrow: options.arrow !== undefined ? options.arrow : true,
            ...options
        });
    } catch (e) {
        console.error('Error initializing tooltip:', e);
    }
}

/**
 * Initialize a card-style tooltip with title and body
 * @param {string} containerId - Container element ID
 * @param {string} iconId - Icon element ID
 * @param {string} textElementId - JSON script element ID containing tooltip text
 * @param {string} borderColor - Border color for the card (e.g., '#9FE2BF')
 */
function initCardTooltip(containerId, iconId, textElementId, borderColor = '#9FE2BF') {
    const tooltipContainer = document.getElementById(containerId);
    const tooltipIcon = document.getElementById(iconId);
    if (!tooltipContainer || !tooltipIcon) return;
    
    // Get translated tooltip text from Django - using JSON script tag
    const tooltipTextElement = document.getElementById(textElementId);
    const tooltipText = tooltipTextElement ? JSON.parse(tooltipTextElement.textContent) : '';
    
    // Remove existing tooltips if any
    if (tooltipIcon._tippy) {
        tooltipIcon._tippy.destroy();
    }
    if (tooltipContainer._tippy) {
        tooltipContainer._tippy.destroy();
    }
    
    try {
        // First, add a simple hover tooltip that shows "click for instructions"
        const hoverTooltipText = "{% trans 'Klicken f√ºr Anweisungen'|escapejs %}";
        initSimpleTooltip(tooltipIcon, hoverTooltipText, {
            placement: 'top',
            delay: [300, 0],
            maxWidth: 200
        });
        
        // Then, add the big card tooltip on click
        const parts = tooltipText.split('\n\n');
        const title = parts[0] || '';
        const body = parts.slice(1).join('\n\n') || '';
        
        // Create a styled card-like tooltip
        const cardContent = `<div style="max-width: 600px; padding: 25px; font-size: 15px; line-height: 1.7; text-align: left; background-color: #ffffff; border-radius: 10px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);"><h3 style="margin: 0 0 15px 0; color: #626262; font-size: 18px; font-weight: bold; border-bottom: 2px solid ${borderColor}; padding-bottom: 10px;">${title}</h3><div style="color: #626262;">${body.replace(/\n/g, '<br>')}</div></div>`;
        
        // Apply big card tooltip to container on click
        initSimpleTooltip(tooltipContainer, cardContent, {
            placement: 'right',
            delay: [0, 0],
            allowHTML: true,
            interactive: true,
            trigger: 'click',
            maxWidth: 650,
            hideOnClick: true
        });
    } catch (e) {
        console.error(`Error initializing card tooltip for ${containerId}:`, e);
    }
}

// Initialize tooltips for canvas elements
function initCanvasTooltips() {
    const canvas = document.getElementById('team-potential-canvas');
    if (!canvas) return;
    
    // Get translated tooltip texts from Django
    const tooltipTexts = {
        integrators: "{% trans 'Gr√ºne Punkte = Integratoren'|escapejs %}",
        bubbleNumbers: "{% trans 'Zahlen in Blasen = Anzahl Safecircle des Spielers'|escapejs %}",
        centerCount: "{% trans 'Zentrum = alle Safecircle im Team (je mehr, desto sicherer und vielf√§ltiger wird die Zusammenarbeit)'|escapejs %}",
        goldenLine: "{% trans 'Goldene Linie = In-Group'|escapejs %}"
    };
    
    // Create a comprehensive tooltip for the canvas
    // Since we can't add tooltips to individual canvas elements easily,
    // we'll add a tooltip to the canvas itself that explains all elements
    const combinedTooltip = `${tooltipTexts.integrators}<br>${tooltipTexts.bubbleNumbers}<br>${tooltipTexts.centerCount}<br>${tooltipTexts.goldenLine}`;
    
    initSimpleTooltip(canvas, combinedTooltip, {
        allowHTML: true
    });
}

// Initialize tooltips after page load
    // ARKS Logo Tooltip
    function initARKSLogoTooltip() {
        const arksLogoContainer = document.querySelector('.header-main__title icon');
        const arksLogoTooltipIcon = document.getElementById('arks-logo-tooltip-icon');
        
        if (arksLogoContainer && arksLogoTooltipIcon) {
            arksLogoContainer.addEventListener('mouseenter', function() {
                arksLogoTooltipIcon.style.display = 'inline-flex';
            });
            arksLogoContainer.addEventListener('mouseleave', function() {
                arksLogoTooltipIcon.style.display = 'none';
            });
            
            initSimpleTooltip(arksLogoTooltipIcon, "{% trans 'Info zu safecircles.ch'|escapejs %}", {
                placement: 'bottom'
            });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initARKSLogoTooltip, 1000);
            setTimeout(initCanvasTooltips, 1000);
            setTimeout(initToleranceWindowTooltip, 1000);
            setTimeout(initPrio1HeadingTooltip, 1000);
            setTimeout(initPrio1IntegratorTooltip, 1000);
            setTimeout(initPrio2HeadingTooltip, 1000);
            setTimeout(initPrio2IntegratorTooltip, 1000);
            setTimeout(initPrio3HeadingTooltip, 1000);
            setTimeout(initPrio3IntegratorTooltip, 1000);
            setTimeout(initPrio4HeadingTooltip, 1000);
            setTimeout(initMinValueButtonTooltip, 1000);
            setTimeout(initMaxValueButtonTooltip, 1000);
            setTimeout(initTeamPotentialTitleTooltip, 1000);
        });
    } else {
        setTimeout(initARKSLogoTooltip, 1000);
        setTimeout(initCanvasTooltips, 1000);
        setTimeout(initToleranceWindowTooltip, 1000);
        setTimeout(initPrio1HeadingTooltip, 1000);
        setTimeout(initPrio1IntegratorTooltip, 1000);
        setTimeout(initPrio2HeadingTooltip, 1000);
        setTimeout(initPrio2IntegratorTooltip, 1000);
        setTimeout(initPrio3IntegratorTooltip, 1000);
        setTimeout(initMinValueButtonTooltip, 1000);
        setTimeout(initMaxValueButtonTooltip, 1000);
        setTimeout(initTeamPotentialTitleTooltip, 1000);
    }

// Initialize tooltip for team potential title
function initTeamPotentialTitleTooltip() {
    initSimpleTooltip('team-potential-title-tooltip-icon', "{% trans 'Schafft sicher verbundene Kreise, in denen Defensivreaktionen √ºberfl√ºssig werden.'|escapejs %}");
}

// Initialize tooltip for tolerance window input
function initToleranceWindowTooltip() {
    initSimpleTooltip('tolerance-window-tooltip-icon', "{% trans 'Das Toleranzfenster ist in der Arche der zentrale Mechanismus zur Visualisierung psychologischer Sicherheit. Es wird als gr√ºner Bereich um den Team-Mittelwert herum definiert, dessen Breite ein festgelegtes Sicherheitsintervall (z.B. ¬±16 Punkte) vorgibt. Dieser Bereich markiert, welche Unterschiede in der gegenseitigen Wahrnehmung als sicher und akzeptabel gelten. Der erstrebenswerte Team-Sweetspot ist jenes Intervall, in dem die maximale Anzahl psychologisch sicherer Kreise entsteht ‚Äì also stabile Verbindungen, in denen auch schwierige Themen offen besprochen werden k√∂nnen. Ein zu enges Fenster f√ºhrt zu Stress und defensiven Reaktionen, da bereits kleine Abweichungen als Bedrohung wahrgenommen werden. Ein zu weites Toleranzfenster hingegen kann auf problematische Uniformit√§t hindeuten: Es fehlt an notwendigen, herausfordernden Perspektiven, was zu Groupthink und erstarrenden Dynamiken f√ºhren kann. Das Ziel ist somit die Balance ‚Äì ein Gruppen-Toleranzfenster, das Sicherheit gew√§hrt, ohne Lernprozesse zu ersticken.'|escapejs %}");
}

// Initialize tooltip for PRIO 1 heading explanation (big card modal)
function initPrio1HeadingTooltip() {
    initCardTooltip('prio1-heading-tooltip-icon', 'prio1-tooltip-icon', 'prio1-tooltip-text', '#9FE2BF');
}

// Initialize tooltip for PRIO 2 heading explanation (big card modal)
function initPrio2HeadingTooltip() {
    initCardTooltip('prio2-heading-tooltip-icon', 'prio2-tooltip-icon', 'prio2-tooltip-text', '#52CEEC');
}

// Initialize tooltip for PRIO 3 heading explanation (big card modal)
function initPrio3HeadingTooltip() {
    initCardTooltip('prio3-heading-tooltip-icon', 'prio3-tooltip-icon', 'prio3-tooltip-text', '#9FE2BF');
}

// Initialize tooltip for PRIO integrator explanations
function initPrio1IntegratorTooltip() {
    initSimpleTooltip('prio1-integrator-tooltip-icon', "{% trans 'Lasst diese Integratoren Babysteps vorschlagen, die f√ºr gleichberechtigte Redeanteile sorgen, eure Sicherheitsankern gerecht werden und Triggersituationen entspannen k√∂nnen.'|escapejs %}", {
        maxWidth: 350
    });
}

function initPrio2IntegratorTooltip() {
    initSimpleTooltip('prio2-integrator-tooltip-icon', "{% trans 'Lasst die Personen im ersten sicheren Kreis Vorschl√§ge machen, wie eine Integration, sofern gew√ºnscht, noch besser gelingen kann.'|escapejs %}", {
        maxWidth: 350
    });
}

function initPrio3IntegratorTooltip() {
    initSimpleTooltip('prio3-integrator-tooltip-icon', "{% trans 'Welchen Einsatz kann die F√ºhrungskraft leisten, um das Team vom Ist-Wert zur optimalen Konstellation aus Prio 1 zu entwickeln?'|escapejs %}", {
        maxWidth: 350
    });
}

// Initialize tooltip for PRIO 4 heading explanation (big card modal)
function initPrio4HeadingTooltip() {
    initCardTooltip('prio4-heading-tooltip-icon', 'prio4-tooltip-icon', 'prio4-tooltip-text', '#FFD700');
}

// Initialize tooltip for min value button
function initMinValueButtonTooltip() {
    const button = document.getElementById('min-value-button');
    if (!button) return;
    
    try {
        // Use a function to get dynamic content based on whether in-groups exist
        initSimpleTooltip(button, function() {
            const vueApp = window.app1; // Use the global app1 instance
            if (!vueApp) {
                return "{% trans 'Niedrigster verf√ºgbarer Toleranzfenster-Wert'|escapejs %}";
            }
            
            const hasInGroups = vueApp.hasInGroupsAtMin ? vueApp.hasInGroupsAtMin() : false;
            const minValue = vueApp.getMinTolerance ? vueApp.getMinTolerance() : '';
            const firstSafecircle = vueApp.getValue1 ? vueApp.getValue1() : '';
            
            let tooltipText = "{% trans 'Eine Lesehilfe: je kleiner der Zahlenwert, desto mehr Stress und negative Trigger zeigen sich, weil sich die Toleranzfenster der Teammitglieder schliessen.'|escapejs %}";
            
            if (hasInGroups) {
                tooltipText += "\n\n{% trans 'Dieser Wert zeigt In-Groups (goldene Linien) an, die bei niedrigeren Toleranzfenster-Werten existieren als der erste Safecircle. Klicken, um diese Konstellation anzuzeigen.'|escapejs %}";
            } else {
                tooltipText += "\n\n{% trans 'Im ersten sicheren Kreise (bei Toleranzfenster '|escapejs %}" + firstSafecircle + "{% trans ') funktioniert die Zusammenarbeit auch bei sehr grossem Stress noch ohne Drama.'|escapejs %}";
            }
            
            return tooltipText;
        }, {
            maxWidth: 450
        });
    } catch (e) {
        console.error('Error initializing min value button tooltip:', e);
        // Fallback to simple tooltip
        initSimpleTooltip('min-value-button', "{% trans 'Niedrigster verf√ºgbarer Toleranzfenster-Wert'|escapejs %}");
    }
}

// Initialize tooltip for max value button
function initMaxValueButtonTooltip() {
    const button = document.getElementById('max-value-button');
    if (!button) return;
    
    // Get translated tooltip text from Django - combine the text from the section
    // The value will be inserted dynamically when the tooltip is shown
    const tooltipTextPart1 = "{% trans 'Aktuell seid ihr beim Toleranzfenster von '|escapejs %}";
    const tooltipTextPart2 = "{% trans ' alle in EINEM sicheren Kreis.'|escapejs %}";
    const tooltipTextPart3 = "{% trans 'Wenn Einzelne auf undifferenzierte Einigkeit dr√§ngen, zeigt sich das an einer Toleranzfenster-Gr√∂sse von √ºber 35, bei dem die Teamdynamik schon sektenartige Z√ºge tragen kann. Ein weiterer Indikator f√ºr ein ungesundes Mass an erwarteter Konformit√§t zeigt sich bei Werten unter 25, die auf eine Gefahr von Groupthink deutet.'|escapejs %}";
    
    // Remove existing tooltip if any
    if (button._tippy) {
        button._tippy.destroy();
    }
    
    try {
        // Use a function to get dynamic content
        initSimpleTooltip(button, function() {
            // Get the Vue instance to access getValue2()
            const vueApp = window.app1; // Use the global app1 instance
            const maxValue = vueApp ? vueApp.getValue2() : '';
            return `${tooltipTextPart1}${maxValue} ${tooltipTextPart2}\n\n${tooltipTextPart3}`;
        });
    } catch (e) {
        console.error('Error initializing max value button tooltip:', e);
    }
}


    // Use the already parsed all_resultData from above (parsed from json_script tag)
    let data = window.allResultData || [];
    let safezoneData = () => {
        let arr = [];
        for(let item of data) {
            arr.push(item.statusSide);
        }
        return arr
    }

    // Initialize AppGraph only after DOM is ready
    // Only initialize if the container exists (it may not exist on team-potential page)
    function initAppGraphInstance() {
        // Check if container exists - if not, skip AppGraph initialization
        const container = document.querySelector('.custom-graph-wrapper');
        if (!container) {
            // Container doesn't exist on this page - this is normal for team-potential page
            // No need to retry or log warnings
            return;
        }

        const {log} = console;

        const app = new AppGraph({
            container: ".custom-graph-wrapper",
            range: [1, 99],
            labelRange: ['Low', 'High'],
            statistic: true,
            mobile: 1200,
            data: data,
            safezoneData: safezoneData(),
        {% comment %} [
            {
               statusSide: 10
            },
            {
               statusSide: 20
            },
            {
               statusSide: 45
            },
            {
               statusSide: 49
            },
            {
                name: 'Vasilisa Kochetkova',
                avatar: '/static/images/avatars/boar.svg',
               statusSide: 49
            },
            {
               statusSide: 49
            },
            {
               statusSide: 49
            },
            {
               statusSide: 49
            },
            {
               statusSide: 60
            },
            {
               statusSide: 70
            },
            {
               statusSide: 99
            },
        ] {% endcomment %}
        });
    }
    {% comment %} var css_change = function(t,s){
        s = document.createElement('style');
        s.innerText = t;
        document.body.appendChild(s);
    };

    var median = {{ median }};
    var low = median - 16;
    var high = median + 16;
    if (low < 0){
        low = 0;
    }
    if (high > 100){
        high = 100;
    }
    var blue_range = high - low;
    css_change(`.statistic .custom-graph__items:before{left:${low}%;width:min(${blue_range}%);}`); {% endcomment %}


    //document.getElementById('button').addEventListener('click', function (e) {
    //    e.preventDefault();
    //    log(app.getData())
    //});

    /**
     * Google Slides Fullscreen functionality
     * Handles entering/exiting fullscreen mode with cross-browser compatibility
     */
    const fullscreenButton = document.getElementById('google-slides-fullscreen-button');
    const slidesContainerWrapper = document.querySelector('.google-slides-container-wrapper');
    
    if (fullscreenButton && slidesContainerWrapper) {
        const fullscreenIcon = fullscreenButton.querySelector('.fullscreen-icon');
        const enterFullscreenLabel = "{% trans 'Vollbild anzeigen'|escapejs %}";
        const exitFullscreenLabel = "{% trans 'Vollbild beenden'|escapejs %}";
        
        /**
         * Check if currently in fullscreen mode
         * @returns {boolean}
         */
        const isFullscreen = () => {
            return !!(document.fullscreenElement || 
                     document.webkitFullscreenElement || 
                     document.mozFullScreenElement || 
                     document.msFullscreenElement);
        };
        
        /**
         * Request fullscreen with cross-browser support
         */
        const requestFullscreen = () => {
            const element = slidesContainerWrapper;
            if (element.requestFullscreen) {
                element.requestFullscreen().catch(err => {
                    console.error('Error entering fullscreen:', err);
                });
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
        };
        
        /**
         * Exit fullscreen with cross-browser support
         */
        const exitFullscreen = () => {
            if (document.exitFullscreen) {
                document.exitFullscreen().catch(err => {
                    console.error('Error exiting fullscreen:', err);
                });
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
        };
        
        /**
         * Update UI state based on fullscreen status
         */
        const updateFullscreenUI = () => {
            if (isFullscreen()) {
                slidesContainerWrapper.classList.add('fullscreen');
                if (fullscreenIcon) fullscreenIcon.textContent = '‚õ∂';
                fullscreenButton.setAttribute('aria-label', exitFullscreenLabel);
                fullscreenButton.setAttribute('title', exitFullscreenLabel);
            } else {
                slidesContainerWrapper.classList.remove('fullscreen');
                if (fullscreenIcon) fullscreenIcon.textContent = '‚õ∂';
                fullscreenButton.setAttribute('aria-label', enterFullscreenLabel);
                fullscreenButton.setAttribute('title', enterFullscreenLabel);
            }
        };
        
        // Toggle fullscreen on button click
        fullscreenButton.addEventListener('click', () => {
            if (isFullscreen()) {
                exitFullscreen();
            } else {
                requestFullscreen();
            }
        });
        
        // Listen for fullscreen changes (cross-browser)
        const fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'];
        fullscreenEvents.forEach(event => {
            document.addEventListener(event, updateFullscreenUI);
        });
    }

    /**
     * Print optimization: Scale canvas to fit page width
     * Stores original canvas dimensions and restores them after printing
     */
    let originalCanvasStyle = null;
    
    function prepareCanvasForPrint() {
        const canvas = document.getElementById('team-potential-canvas');
        if (!canvas) {
            console.warn('Canvas element not found for print preparation');
            return;
        }
        
        // Store original style if not already stored
        if (!originalCanvasStyle) {
            originalCanvasStyle = {
                width: canvas.style.width || '',
                height: canvas.style.height || '',
                maxWidth: canvas.style.maxWidth || '',
                maxHeight: canvas.style.maxHeight || ''
            };
        }
        
        // Calculate available print width (A4 landscape: ~27cm = ~1020px at 96dpi, minus margins)
        const printWidth = Math.min(950, window.innerWidth - 40); // Leave 20px margin on each side
        const scale = printWidth / 1000; // Scale factor based on canvas width of 1000px
        
        // Scale canvas for print
        canvas.style.width = `${printWidth}px`;
        canvas.style.height = `${1000 * scale}px`;
        canvas.style.maxWidth = '100%';
        canvas.style.maxHeight = 'none';
    }
    
    /**
     * Restore canvas size after printing
     */
    function restoreCanvasAfterPrint() {
        const canvas = document.getElementById('team-potential-canvas');
        if (canvas && originalCanvasStyle) {
            canvas.style.width = originalCanvasStyle.width;
            canvas.style.height = originalCanvasStyle.height;
            canvas.style.maxWidth = originalCanvasStyle.maxWidth;
            canvas.style.maxHeight = originalCanvasStyle.maxHeight;
            originalCanvasStyle = null;
        }
    }
    
    // Listen for print events
    window.addEventListener('afterprint', restoreCanvasAfterPrint);
    
    // Also restore on beforeunload to ensure cleanup
    window.addEventListener('beforeunload', () => {
        if (originalCanvasStyle) {
            restoreCanvasAfterPrint();
        }
    });

</script>

</body>
</html>